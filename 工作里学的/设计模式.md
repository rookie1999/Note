## 创建型模式

### 单例模式

> 注意：单例不能与泛型一起使用（有泛型缓存）

#### 饿汉式



#### 懒汉式

延迟创建对象的时间



### 原型模式

> 当克隆的性能优于实例化的时候使用原型模式

解决对象重复创建的问题

通过`MemberwiseClone`来clone新对象，避免重复创建

```c#
public class Singleton
{
    private Singleton(){}
    private static Singleton _instance = new Singleton();
    
    public static Singleton CreateInstancePrototype()
    {
        return (Singleton) _instance.MemberwiseClone();
    }
}
```



### 工厂模式

#### 简单工厂

把构造实例的方法转移到简单工厂中

```c#
public interface IHuman {}
public class ChinesePeople : IHuman {}
public class JapanesePeople : IHuman {}

public class HumanFactory
{
    public static IHuman GetInstance(string nation)
    {
        IHuman human;
        switch (nation)
        {
            case "chinese":
                human = new ChinesePeople();
            case "Japanese":
                human = new JapanesePeople();
        }
        return human;
    }
}
```



#### 工厂方法

> 工厂可以增加一些创建逻辑，屏蔽对象实例化的复杂度
>
> 可以扩展（通过继承工厂，重写工厂方法）
>
> 克服简单工厂中违反开闭原则的问题
>
> 缺点：每个实现类对应一个工厂，增加开发量

一个工厂用来创建一个接口的实例

```c#
public interface IHuman {}
public class Human : IHuman {}
public class HumanFactory 
{
    public IHuman GetHuman()
    {
        return new Human();
    }
}
```



#### 抽象工厂

> 工厂+约束

一个工厂提供几个接口用来创建几个有联系的对象（作为一个整体）

比如`SqlClientFactory`用来创建DbParameter、DbConnection、DbCommand, DbDataAdapter





## 行为型模式

> 关注对象和行为的分离

### 模板方法模式

固定的步骤代码（模板）在父类确定（流程固定），每一步的详细细节交给子类实现



### 观察者模式

> 一个对象在某件事发生之后，会触发一系列动作，但是对象又不想和那个动作的触发类有紧密的依赖

#### 通用写法

```c#
Cat cat = new Cat();
Mouse mouse = new Mouse();
Dog dog = new Dog();
cat.RegisterObserver1(mouse);
cat.RegisterObserver1(dog);
cat.Miao1();

public interface IObserver
{
    void Action();
}
public class Cat
{
    private List<IObserver> _observerList = new List<IObserver>();

    public void RegisterObserver1(IObserver observer)
    {
        _observerList.Add(observer);
    }

    public void Miao1()
    {
        Console.WriteLine("Miao!");
        foreach (var observer in _observerList)
            observer.Action();
    }
}
public class Dog : IObserver
{
    public void Action()
    {
        Console.WriteLine("Wang!");
    }
}
public class Mouse : IObserver
{
    public void Action()
    {
        Console.WriteLine("Zhi!");
    }
}
```



#### C#事件

```c#
Cat cat = new Cat();
cat.RegisterEvent(new Dog().Wang);
cat.RegisterEvent(new Mouse().Zhi);
cat.Miao();

public class Mouse
{
    public void Zhi()
    {
        Console.WriteLine("Zhi!");
    }
}
public class Dog
{
    public void Wang()
    {
        Console.WriteLine("Wang!");
    }
}
public class Cat
{
    private event Action miaoEvent;

    public void RegisterEvent(Action action)
    {
        miaoEvent += action;
    }

    public void Miao()
    {
        Console.WriteLine("Miao!");
        miaoEvent.Invoke();
    }
}
```



### 责任链模式

一件事要经过不同的流程（当先发生的流程搞不定的时候），一个流程处理不了，需要调用下一个流程

责任链模式：将下一流程的接口方法调用封装到上一流程的处理方法中，然后将上一流程对下一流程的对象指定交给最上端





## 结构型模式

### 适配器模式

#### 类适配器模式

通过继承Adaptee类，并实现Target接口



#### 对象适配器模式

通过组合Adaptee类，并实现Target接口



### 代理模式

> 传达原来的业务逻辑，但是会增加一些方法前后的逻辑
>
> AOP切面编程

比如：日志代理，避免侵入业务代码



### 装饰器模式

> 组合+继承
>
> 用来增强已经存在的类
>
> 对于一个需要被增强的类A，增强类B实现A的接口，并将A的实例组合进来



