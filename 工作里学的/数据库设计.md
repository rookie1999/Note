# 数据库设计

1. 需求分析
2. 概要设计阶段 E-R图 表-属性-关系图
3. 详细设计



## 表的关系

* 一对一
  * 不多见，一般写到一张表里（除非是两个实体）
* 一对多
  * 多的那张表使用外键连接到一的那张表
* 多对多
  * 使用第三张表专门存储多对多的映射



## 三大范式

* 每一列保持原子性，不可分割
* 每一列都和主键有关，一张表只该描述一个对象
* 每一列都是主键的直接依赖（直接相关），而不是间接相关



## 名词

### 自增ID

int/bigint，SQL server会默认创建聚集索引，空间小，可以有业务意义（如大于1000w是新用户）



### ACID

A： 原子性

​	要么都成功，要么都失败

C：一致性

​	事务执行完，数据都正确

I：隔离性

​	两个事务同时操作一张表，要么A事务先执行完，要么B事务先执行完（通过锁表）

D：持久性

​	事务提交之后，不可更改

​	

### 外键

尽量少的使用外键，大型互联网项目的瓶颈一般都在数据库（尽量少让数据库做事）

更多的是使用程序来完成，虚拟外键



### 字段

字段尽量非空，不然有些查询会没有结果，一般会给个默认值



### 统计字段

* 创建时间

* 创建人
* 最后更新时间
* 最后更新人
* state
* isEnable

除了映射表，其他表都应该增加这些字段



### 软删除



## 权限系统数据库设计

用户——角色

角色——权限

用户——权限（这里是直接赋予特殊权限，比如新功能和隐藏功能）



部门——数据权限

做法1：核心数据带上部门ID

做法2：给数据增加一个path字段，子用户和数据都在path加长，查询的时候过滤`path like 'path%'`



### 主从表

主表：保存基本信息+统计信息

从表：（外键）单项商品的信息

比如：order——order_detail

主表做管理，从表做详情



## 无限级别

一级类对应下面二级类，二级类对应下面三级类，...

每个类别一张表不太合适，因为级别是可扩展的而且有很多外键关系

其实每个类别的基本信息一样，不一样的是类别号

解决方法：

* 使用level字段级别区分
* 使用ParentID进行追溯（建立树结构）



### 如何找到某个类别的全部子类

使用path字段

一级类别：`root/Guid`

二级类别：`父类的path/Guid`



## 用户互相关注问题

A关注B

B关注A

AB互相关注



一开始想到的是使用一张关注映射表

（id、sourceID、targetID、createDate、updateDate、...）

可以实现A关注B，B关注A，A的关注列表（sourceID=A），A的粉丝列表（targetID=B），A的互粉列表（先找出A的关注列表，再查找targetID=A且sourceID in A的关注列表），取消关注（软删除）



第二种解决方法是使用一个flag字段

（id、userID_1，userID_2，flag）

userID_1是小的id，userID_2是大的id

flag：1是左关注右，2是右关注左，3是互相关注

这种解决方法对A的关注列表和粉丝列表不太友好，需要使用union或别的方法



第三种解决方法是在第一种解决方法的基础上，使用额外的一个视图，视图里面有互粉字段



## 数据库负载均衡

Moebius for SQL Server

![image-20220129190554659](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220129190554659.png)



## 读写分离

缓解数据库压力

基于二八原则：20%是写，80%是读

**第一种方法**：基于`日志传送`

主服务器将作业从日志或者缓冲区写入到共享文件夹，监控服务器和从服务器会读取共享文件夹，并还原作业

有延迟

**第二种方法**：事务复制

* 快照复制：定时做快照snapshot，通过文件夹共享，从数据库周期性恢复
  * 及时性差
  * 不适合大批量修改的
* 事务复制
  * 发布服务器：主数据库
  * 订阅服务器：从数据库
  * 复制代理：发布服务器指定的，
    * 在发布服务器：推
    * 在订阅服务器：拉
  * ![image-20220129192713673](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220129192713673.png)
  * 当发布服务器将一个作业推送至分发服务器之后，分发服务器会广播到每个订阅服务器
* 合并复制
  * 用得少
  * 在事务复制的基础上，可以允许从数据库同步到主数据库



## 分库分表

缓解数据库压力

* 分表

  * 垂直分表
    * 把一张表分成两张表
    * 表的真实情况是硬盘文件的一个文件，文件越大，访问越慢
    * 有些数据`占空间——更新少——查询少`，就分离出去
  * 水平分表
    * 每个表的表结构是一样的
    * 时间分表
      * 因为很多数据是实时性的，过期的数据大部分都没有用
    * 类别分表
      * 比如地域
      * 不同的地域的数据是不冲突的
    * 唯一标识分表
      * 按id取余均匀分配
    * 有数据更新，先根据拆分字段定位表，再更新
    * 查询？没有好的办法，只能使用别的技术手段，比如全文检索lucene
    * 跨表查询没有别的好办法，要么做个合并表，要么union，要么业务支持
  * 表分区
    * 数据库提供的功能
    * 可以按照条件，把一张表的数据分开成不同的硬盘文件
    * 技术优点和缺点与水平分表类似

* 分库

  * 垂直分库

    * 按照业务进行分库，用多个服务器分担压力

    * 划分成多个模块

      > Q：如果一个业务需要多个数据
      >
      > 不要使用多个数据库连接进行查询，而是使用服务的方式
      >
      > Q：事务怎么办
      >
      > 最终一致性策略，A完成，写个任务给B，B失败则重试，还失败通知A回滚或人工介入

  * 水平分库

    * 和水平分表类似拆分多个库
    * 按照时间
    * 按照地域
    * 如果需要总的报表，可以创建一个报表库，定时做汇总数据
