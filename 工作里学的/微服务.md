## 微服务架构

### 单体架构

整个系统运行在一个进程中

缺点：

* 基本上只能采用一种技术
* 系统耦合性很强，一旦其中一个模块有问题，整个系统就瘫痪了；一旦升级其中一个模块，整个系统就停机了
* 要上线必须一起上线，互相等待，无法快速响应需求
* 集群也只能是复制整个系统，即使只是其中一个模块压力大

### 微服务架构

不同模块放在不同的进程/服务器上，模块之间通过网络通讯进行协作

优点：

* 可以使用不同的语言或者语言不同版本开发不同模块
* 系统耦合性弱，其中一个模块有问题，可以通过“降级熔断”等手段来保证系统不雪崩
* 可以独立上线，能够迅速响应新需求
* 可以对不同模块使用不同的集群策略，哪里慢集群哪里

缺点：

* 开发难度大，系统结构更复杂
* 运行效率低

微服务架构需要处理的问题

* 服务间通讯
* 服务治理与服务发现
* 网关和安全认证
* 限流与容错
* 监控
* ...

腾讯微信支付清算网关 微服务架构：Consul+Ocelot+.Net Core+Polly

Consul是服务治理与服务发现，Polly做熔断降级，Ocelot做网关

在微服务中，服务之间的通讯有两种主要形式：

*  Restful，也就是传输Json格式数据，.Net中对应的就是WebAPI技术，类似于ASP.Net MVC，可以使用Postman方便地调试接口
* 二进制RPC：二进制传输协议，比Restful用的Http通讯效率更高，但是耦合性更强。技术有Thrift，gRPC（也支持http）等



### Consul服务治理与发现

> Consul 是注册中心，服务提供者、服务消费者等都要注册到Consul中，这样就可以实现服务提供者、服务消费者的隔离
>
> 除了Consul之外，还有Eureka、ZooKeeper等类似软件
>
> Consul是存储服务名称与IP端口对应关系的服务器

Consul会定期向注册的服务发送请求，用来确认服务是否存在



#### Consul安装与配置

1. 下载地址：`https://www.consul.io`

   开发环境中可以只配置一台Consul服务器，在生产环境中需要建立集群，至少需要一台server，多台agent

   开发环境中Consul重启数据就会丢失

   默认占用8300,8500等端口，可以通过`localhost:8500`访问

2. 通过nuget安装Consul组件



#### Consul的功能

* 提供服务到IP地址的注册
* 提供服务到ip地址列表的查询
* 对提供服务方的健康检查（HealthCheck）



#### Consul服务治理

> Consul只保存服务名、ip、端口这些信息，至于服务提供什么接口、方法、参数、Consul不管，需要消费者知道服务的这些细节
>
> 
>
> 服务治理指的是服务的注册、注销和健康检查

##### 注册

location: MsgService

```c#
// ip, port, name, id of service
// id cannot be the same while the name can be
string ip = Configuration["ip"];
string port = Configuration["port"];
string serviceName = "MessageService";
string serviceId = serviceName + Guid.NewGuid();
using (var consulClient = new ConsulClient(ConsulConfig))
{
    // Register a service
    AgentServiceRegistration serviceRegistration = new AgentServiceRegistration();
    serviceRegistration.Address = ip;  // ip address of registered service, and this ip should be able to access by outsiders
    serviceRegistration.Port = Convert.ToInt32(port);
    serviceRegistration.ID = serviceId;
    serviceRegistration.Name = serviceName;
    // health check
    serviceRegistration.Check = new AgentServiceCheck()
    {
        DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5), // no service after 5s, the service will be deregistered.
        HTTP = $"http://{ip}:{port}/api/HealthCheck", // url of health check
        Interval = TimeSpan.FromSeconds(10), // conduct a health check every 10s
        Timeout = TimeSpan.FromSeconds(5), // stop after 5s with no response when health checking
    };
    // must wait because of async invoke
    consulClient.Agent.ServiceRegister(serviceRegistration).Wait(); 
}

// deregister service when service is stopped normaly
applicationLifetime.ApplicationStopped.Register(() => { 
    using (var consulClient = new ConsulClient(ConsulConfig))
    {
        Console.WriteLine("The message service is stopped.");
        consulClient.Agent.ServiceDeregister(serviceId).Wait();
    }
});


private void ConsulConfig(ConsulClientConfiguration config)
        {
            config.Address = new Uri("http://127.0.0.1:8500");  // Consul Server's url
            config.Datacenter = "dc1";
        }
```

AgentServiceRegistration的Tags属性可以用来存储数据



##### health check

```c#
using Microsoft.AspNetCore.Mvc;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace ConsulDemo.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class HealthCheckController
    {
        [HttpGet]
        public ActionResult<string> Get()
        {
            Console.WriteLine("Health Check on " + DateTime.Now);
            return "OK";
        }
    }
}

```



#### 服务发现

> 服务的发现指的是服务的消费

location: ClientDemo

```c#
using (var client = new ConsulClient(s => { 
    s.Address = new Uri("http://127.0.0.1:8500"); s.Datacenter = "dc1";}))
{
    /*var services = client.Agent.Services().Result.Response;
                foreach (var k in services.Keys)
                {
                    Console.WriteLine(k + " >>> id:" + services[k].ID + ", name:" + 
                        services[k].Service + ", addr:" + services[k].Address+ ":" + services[k].Port);
                }*/
    var services = client.Agent.Services().Result.Response.Values.Where(service => "productservice".Equals(service.Service, StringComparison.OrdinalIgnoreCase));
    var selectedService = services.ElementAt(Environment.TickCount % services.Count());
    using (HttpClient httpClient = new HttpClient())
    {
        // Get
        //var products = httpClient.GetAsync($"http://{selectedService.Address}:{selectedService.Port}/api/product").Result;
        //Console.WriteLine($"http://{selectedService.Address}:{selectedService.Port}/api/product");

        // Post
        using (var httpContent = new StringContent("{\"ID\":\"222\", \"Name\":\"XXXX\", \"Price\":\"988\", \"Description\":\"66666!\"}", 
                                                   Encoding.UTF8, "application/json"))
        {
            var ret = httpClient.PostAsync($"http://{selectedService.Address}:{selectedService.Port}/api/product", httpContent).Result;
            Console.WriteLine(ret.StatusCode);
        }
    }
}
```



## 熔断降级

> 熔断就是保险丝。当出现某些状况时，切断服务，从而防止应用程序不断地尝试执行可能会失败的操作给系统造成“雪崩”，或者大量的超时等待导致系统卡死
>
> 降级的目的是当某个服务提供者发生故障的时候，向调用方法返回一个错误响应或者替代响应。举例子：调用联通接口服务器发送短信失败之后，改用移动服务器发送短信，如果移动短信服务器也失败，则改用电信服务器，如果还失败，返回“失败”响应。在推荐商品服务器加载数据的时候，如果失败，则改用从缓存中加载，如果在缓存中加载也失败，则返回一些本地替代数据



### Polly

> 可以用来简化熔断降级的处理

**主要功能**

* 重试 Retry
* 断路器 Circuit-breaker
* 超时检测 Timeout
* 缓存 Cache
* 降级 FallBack 

```
Polly的策略由“故障”和“动作”两部分组成，“故障”包括异常、超时、返回值错误等情况，“动作”包括Fallback（降级）、重试（Retry）、熔断（Circuit-breaker）等
策略用来执行可能会有故障的业务代码，当业务代码出现“故障”情况的时候就执行动作
```



#### Fallback 降级

fallback with no return value

```c#
Policy policy = Policy.Handle<ArgumentException>()//故障
    .Fallback(() => {  // 动作
        Console.WriteLine("Fallback handle");
    });
policy.Execute(() =>
               {
                   // buiness logic code
                   Console.WriteLine("Start to run Buiness Logic");
                   throw new ArgumentException();
                   Console.WriteLine("End to run Business Logic");
               });
```

Another overload method for Fallback is `Fallback(Action, ex => ...);` Ex: Exception object



fallback with a return value

```c#
Policy<string> policy = Policy<string>.Handle<ArgumentException>()
    .Fallback(() => {
        return "Value after fallback";
    });
string value = policy.Execute(() => {
    throw new ArgumentException();
    return "Normal value";
});
Console.WriteLine(value);
```



#### Retry 重试

```c#
Policy policy = Policy.Handle<Exception>()
    .RetryForever();
```

* Retry()
  * 重试一次
* Retry(n)
  * 重试n次
* RetryForever()
  * 一直重试直到成功
* WaitAndRetry
  * 可以实现类似出错等待100秒再试
  * WaitAndRetry(10, i => TimeSpan(i))
    * 尝试10次，每次的等待间隔的秒数为当前的次数



#### Circuit Breaker 短路保护

> 避免服务不可用，还是使劲请求给系统造成更大压力

出现N次连续错误，则把“熔断器”熔断，等待一段时间，等待这段时间内如果再Execute，则直接抛出BrokenCircuitException异常，等待时间过去，再执行Execute的时候如果又错了（这时错一次就可以了），那么继续熔断一段时间，否则就恢复正常

* CircuitBreaker(num, TimeSpan.FromSeconds(sec));
  * 连续num次错误，熔断sec秒

```c#
Policy policy = Policy.Handle<ArgumentException>().CircuitBreaker(5, TimeSpan.FromSeconds(5));

while (true)
{
    try
    {
        Console.WriteLine("Start to execute");
        policy.Execute(() =>
                       {
                           Console.WriteLine("Start to run");
                           throw new ArgumentException();
                           Console.WriteLine("End to run");
                       });
    }
    catch (Exception e)
    {
        Console.WriteLine(e);
    }
    Thread.Sleep(500);
}
```



#### 策略封装

* policy3 = policy1.Wrap(policy2)
  * 此时执行policy3，就会把policy1和policy2一起执行
  * 顺序是policy2先执行（被wrap的），出现故障再执行policy1
* policy4 = Policy.Wrap(policy1, policy2, policy3)

```c#
Policy policyRetry = Policy.Handle<Exception>().Retry(3);
Policy policyFallback = Policy.Handle<Exception>().Fallback(() => {
    Console.WriteLine("fallback");
});
Policy policyWrap = policyFallback.Wrap(policyRetry);
policyWrap.Execute(() => {
    Console.WriteLine("Start");
    throw new ArgumentException();
});
```



#### Timeout 超时

Timeout与其他故障动作策略一起包装后使用

若超时3秒执行Fallback动作

```c#
Policy policyTimeout = Policy.Timeout(3, Polly.Timeout.TimeoutStrategy.Pessimistic);
Policy policyFallback = Policy.Handle<Exception>().Fallback(() => {
    Console.WriteLine("Fallback");
});
Policy policyWrap = policyFallback.Wrap(policyTimeout);
policyWrap.Execute(() =>
                   {
                       Console.WriteLine("Start");
                       Thread.Sleep(5000);
                       Console.WriteLine("End");
                   });
```



#### 对异步的支持

除了Handle方法，其他方法均加上`Async`



#### AOP

如果将熔断降级策略代码与业务代码写在一起，很容易污染业务代码

可以使用AOP的思想，将熔断降级策略代码作为切面加入

使用`AspectCore` package来引入AOP

**业务逻辑类**

```c#
public class BusinessLogic
{
    [Custom]
    public virtual void BusinessLogicMethod()
    {
        Console.WriteLine("Run the Business Logic");
    }
}
```

**切面类**

```c#
public class CustomAttribute : AbstractInterceptorAttribute
{
    public async override Task Invoke(AspectContext context, AspectDelegate next)
    {
        Console.WriteLine("Before the business logic");
        await next(context); // 调用业务方法
        Console.WriteLine("After the business logic");
    }
}
```

**使用**

```c#
ProxyGeneratorBuilder proxyGeneratorBuilder = new ProxyGeneratorBuilder();
using (IProxyGenerator proxyGenerator = proxyGeneratorBuilder.Build())
{
    BusinessLogic business = proxyGenerator.CreateClassProxy<BusinessLogic>();
    business.BusinessLogicMethod();
}
```





## 常用tips

### 设定监听端口

#### 命令行

修改环境变量

```
// 只影响当前命令行
set ASPNETCORE_URLS=http://127.0.0.1:8080
```

#### 程序

```c#
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
    .ConfigureWebHostDefaults(webBuilder =>
                              {
                                  webBuilder.UseStartup<Startup>()
                                      .UseUrls("http://127.0.0.1:9999");
                              });
```

#### 更高级的方式（推荐）

**程序**

```c#
public static IHostBuilder CreateHostBuilder(string[] args)
{
    var config = new ConfigurationBuilder().AddCommandLine(args).Build();
    var ip = config["ip"];
    var port = config["port"];
    return Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
                                  {
                                      webBuilder.UseStartup<Startup>()
                                          .UseUrls($"http://{ip}:{port}");
                                  });
}
```

再使用命令行启动

```
dotnet WebAPIDemo2.dll --ip 127.0.0.1 --port 9988
```

