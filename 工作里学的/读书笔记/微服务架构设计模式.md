## Chapter One

> 微服务的关键在于服务的拆分

### 单体架构

### 好处

* 应用开发简单
* 易于对应用进行大规模的更改
* 测试相对简单直观
* 部署简单明了
* 横向扩展简单

### 坏处

* 过度的复杂性会吓退开发者
* 开发速度慢
  * 不仅是因为功能难以修复和扩展
  * 项目从编辑、构建到运行和测试费时
* 从代码提交到实际部署的周期很长，而且很容易出现问题
  * 一个小改动就要运行所有的测试，如果测试出错，诊断时间也会漫长
* 难以扩展
  * 不同模块对服务器的要求不一样，单体中所有模块在一个项目里，一般是选择满足所有模块的服务器（这个服务器性能会比想象中的夸张）

* 需要长期依赖某个过时的技术栈



### 扩展立方体和服务

* x轴扩展
  * 又叫水平拆分
  * 是将一个实例水平复制成多个实例
* y轴扩展
  * 又叫垂直拆分
  * 是根据功能性分解把应用拆分为一组服务
* z轴扩展
  * 又叫数据分区
  * 根据请求属性路由到不同的实例

x轴扩展和z轴扩展增加了系统的吞吐量和可用性

y轴扩展解决了日益增长的开发问题和应用的复杂性



### 微服务架构的定义

> 微服务架构影响的更多的还是程序的非功能性需求（nonfunctional requirements），如软件交付速度的可维护性、可扩展性和可测试性

把应用程序功能性分解为一组服务的架构风格

* 微服务使用服务作为模块化的单元
* 服务可以独立部署，服务之间是松耦合的
* 每个服务有自己的私有数据库

#### 好处

* 使大型的复杂应用程序可以持续交付和部署
  * 自动化测试
  * 独立部署
* 每个服务都相对较小并容易维护
* 服务可以独立部署
* 服务可以独立扩展
* 微服务架构可以实现团队的自治
* 更容易采纳和实验新技术
* 更好的容错性
  * 更好的故障隔离

#### 弊端和问题

* 服务如何拆分和定义
* 分布式系统带来的各种复杂性，使开发、测试和部署变得更困难
  * 服务必须使用进程间通信机制
  * 设计服务处理局部故障
  * 处理远程服务不可用或者高延迟的情况
  * 使用`Saga`维护服务之间的数据一致性
  * 使用`API组合`或`CQRS视图`实现跨服务的查询
* 当部署跨越多个服务的功能时需要谨慎地协调更多开发团队
* 开发者需要思考到底应该在应用的什么阶段采用微服务架构



### 微服务架构的模式语言

#### 模式结构的三个重要部分

* 需求 Forces

  * 需求部分描述了必须解决的问题和围绕这个问题的特定上下文环境

* 结果上下文 Resulting context

  * 采用模式后可能带来的后果

  * ```
    结果上下文包含三个部分：
    1. 好处：这个模式带来的好处和它解决了什么需求
    2. 弊端：这个模式的弊端和它没有解决哪些需求
    3. 问题：使用这个模式所引入的新问题
    ```

* 相关模式 Related patterns

  * 描述了模式与模式之间的关系
  * 模式的关系
    * 前导 Predecessor
      * 前导模式是催生这个模式的需求的模式
    * 后续 Successor
      * 后续模式是指用来解决当前模式引入的新问题的模式
    * 替代 Alternative
    * 泛化 Generalization
      * 针对一个问题的一般性解决方案
    * 特化 Specialization
      * 针对特定模式的具体解决方案

![image-20220221163818427](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220221163818427.png)

> 微服务架构模式语言是微服务相互关联的软件架构和设计模式的集合

![image-20220221164131767](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220221164131767.png)

* 基础设施相关模式组
  * 这些模式解决通常是在开发环节跟基础设施有关的问题
* 应用基础设施相关模式组
  * 这些模式解决应用层面的基础设施相关问题
* 应用相关模式组
  * 这些模式解决开发人员面对的具体技术和架构问题



#### 相关模式

* 服务拆分的相关模式

  * 根据业务能力分解模式
  * 根据子域分解模式

* 通信的相关模式

  * > 使用微服务架构构建的应用程序是分布式系统
    >
    > 进程间通信（IPC）很重要

  * 通信风格： 使用哪一类进程间通信机制
  * 服务发现： 客户端如何获得服务具体实例（如HTTP请求）的IP地址
  * 可靠性： 在服务不可用的情况下，如何确保服务之间的可靠性？
  * 事务性消息： 如何将消息发送、事件发布这样的动作与更新业务数据的数据库事务集成？
  * 外部API： 应用程序的客户端如何与服务进行通信？
  * ![image-20220221165217621](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220221165217621.png)

* 实现事务管理的数据一致性相关模式

  * > 两步式提交（two phase commit, 2PC）**不再适用**

  * Saga模式

* 在微服务架构中查询数据的相关模式

  * API组合模式
    * 逐一调用服务的API然后把所有的返回聚合在一起
  * 命令查询职责隔离（CQRS）

* 服务部署的相关模式

  * 使用部署平台来部署和管理这些服务

* 可观测性的相关模式

  * 健康检查API
    * 返回服务健康状态的API
  * 日志聚合
    * 把服务产生的日志写入一个集中式的日志服务器，这个服务器可以提供日志搜索，也可以根据日志情况触发报警
  * 分布式追踪
    * 为每一个外部请求分配一个唯一的ID，用于在各个服务之间追踪外部请求
  * 应用指标
    * 供维护使用的指标，例如计数器等，导出到指标服务器
  * 审计日志
    * 记录用户的行为

  * 实现服务自动化测试的相关模式
    * 消费端驱动的契约测试
      * 验证服务满足客户端所期望的功能
    * 消费端契约测试
      * 验证服务的客户端可以正常与服务通信
    * 服务组件测试
      * 在隔离的环境中测试服务
  * 解决基础设施和边界问题的相关模式
    * 使用微服务基底模式（支撑微服务架构的应用层基础设施）
      * 在现有成熟的基底框架之上构建服务
  * 安全相关的模式
    * API Gateway
      * 用户验证 
      * 常见解决方案： 应用访问令牌模式
      * API Gateway将访问令牌（如JWT）传递给服务，这些服务可以验证令牌并获取有关用户的信息

### 流程与组织

<img src="C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220301110516182.png" alt="image-20220301110516182" style="zoom:150%;" />



#### 组织

大团队的沟通成本会上升，而小团队是更推荐的

每个团队都有一个明确的职责：负责开发或运维一个或多个服务，团队是跨职能的，可以独立完成开发、测试和部署等

#### 流程

> 进行软件开发和交付的流程

```
持续交付：持续交付能够以可持续的方式安全、快速地将所有类型的更改（包括新功能、配置更改、错误修复和实验）交付到生产环境或用户手中
```

评估软件开发的四个有用指标：

* 部署频率：软件部署到生产环境中的频率
* 交付时间：从开发人员提交变更到变更被部署的时间
* 平均恢复时间：从生产环境问题中恢复的时间
* 变更失败率：导致生产环境问题的变更提交百分比



## Chapter Two 服务的拆分策略

> * 使用拆分模式中的业务能力模式和子域模式进行单体应用到服务的拆分
> * 使用领域驱动设计的限界上下文概念来分解数据，并让服务拆分变得更容易

微服务的关键在于服务的拆分



### 软件架构

```
软件架构：软件的架构是一种抽象的结构，它由软件的各个组成部分和这些部分之间的依赖关系构成。
软件架构的定义：计算机系统的软件架构师构建这个系统所需要的一组结构，包括软件元素、他们之间的关系以及两者的属性。

架构的目标是可扩展性、可靠性和安全性，并且可以快速安全交付（可维护性、可测试性和可部署性）。

软件架构对应用程序的质量属性有显著的影响。
```



#### 软件架构的4+1视图模型

![image-20220301161507857](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220301161507857.png)

每个场景负责描述在一个视图中的多个架构元素如何协奏，以完成一个请求。



### 架构风格

> 六边形架构和分层架构（三层架构）构成了软件的逻辑视图

架构的重要性在于，他帮助应用程序满足了非功能性需求（应用程序有两种需求，一个是功能性需求，一般包含在use case或者是use story中，另一个就是非功能性需求）

功能性需求决定程序做什么

非功能性需求决定应用程序在运行时的质量，比如可扩展性和可靠性；同时也包含在开发阶段的质量，比如可维护性、可测试性、可扩展性和可部署性



架构风格是一系列设计决策，限制了建筑的特征和建筑材料

特定的架构风格提供了有限的元素（组件）和关系（连接器）。

#### 分层式架构风格

软件元素按照“层”的方式组织，每个层都有明确定义的职责，并且限制了层之间的依赖关系。每一层只能依赖于紧邻其下方的层或其下面的任何层

流行的三层架构：

* 表现层：包含实现用户界面或外部API的代码
* 业务逻辑层：包含业务逻辑
* 数据持久化层：实现与数据库交互的逻辑

弊端：表现层不可以由多个外部系统调用（web、安卓等），数据库层无法与多个数据库交互，业务逻辑依赖数据持久化层并难以测试

还有一个不是很明显的弊端是依赖关系与分层架构描述的相反



#### 六边形架构风格

> * 以业务逻辑为中心的方式组织逻辑视图
> * 应用程序有一个或多个**入站适配器**，而不是表示层，调用业务逻辑
> * 应用程序具有一个或多个**出站适配器**，而不是数据持久化层，被业务逻辑调用，并调用外部应用程序

优点：业务逻辑不依赖于适配器。相反地，各种适配器都依赖业务逻辑

![image-20220301163347279](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220301163347279.png)

入站适配器通过调用入站端口来处理来自外部世界的请求。一个实例是Spring MVC Controller，它实现了一组REST接口或一组web页面。另一个实例是订阅消息的消息代理客户端。多个入站适配器可以调用相同的入站端口。

出站适配器实现出站端口，并通过调用外部应用程序或服务处理来自业务逻辑的请求。一个实例是实现访问数据库的操作的数据访问对象（DAO）类，另一个实例是调用远程服务的代理类。出站适配器也可以发布事件

六边形架构风格的一个重要好处是它将业务逻辑与适配器中包含的表示层和数据访问层的逻辑分离开。



#### 单体架构与微服务架构

> 单体架构和微服务架构体现了应用程序的实现视图

* 单体架构：将应用程序构建为单个可执行和可部署组件
  * 单体架构也可以使用六边形架构风格

* 微服务架构：将应用程序构建为松耦合、可独立部署的一组服务
  * 实现视图由多个组件构成：一组可执行文件或war文件。组件是服务，连接器是使这些服务能够协作的通信协议。
  * 每个服务都有自己的逻辑视图架构通常也是六边形架构

​	![image-20220301171513043](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220301171513043.png)



* 微服务架构强加的一个关键约束是`服务松耦合`	
* 微服务架构强制实现了应用程序的模块化
* 微服务架构最核心的特性是服务之间的松耦合性（loose coupling）
* 



##### 服务

服务是一个单一的、可独立部署的软件组件

服务具有API，为客户端提供对功能的访问

有两种类型的操作：命令和查询

API由命令、查询和事件组成

命令：createOrder() 执行操作并更新数据

查询：findOrderById() 检索数据

发布事件： 供其他客户端使用，如OrderCreated

每个服务都有自己的架构，可能还有独特的技术栈。

API由与服务的业务逻辑交互的适配器实现，操作适配器调用业务逻辑，事件适配器对外发布业务逻辑产生的事件

![image-20220301172234409](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220301172234409.png)



服务之间松耦合

尽量减少共享库，可以将共享库作为服务暴露出去，如果是共享库修改了，所有依赖共享库的服务需要重新部署。所有共享库适合那些不会轻易改变的代码

如果一个服务的修改经常会影响到另一个服务的修改，那么服务并没有实现松耦合，本质上还是一个分布式的单体



#### 定义软件的架构

![image-20220302130655519](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220302130655519.png)



第一步：将应用程序的需求提炼为各种关键请求（用系统操作描述）

​		系统操作：应用程序必须处理的请求的一种抽象描述

第二步：

