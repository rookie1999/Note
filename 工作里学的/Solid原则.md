## 面对对象设计原则概述

### 软件的可维护性和可复用性

可维护性较低的软件：

* 过于僵化（Rigidity）
  * 设计难以修改
* 过于脆弱（Fragility）
  * 设计易遭到破坏
* 牢固性（Immobility）
  * 复用性低
* 黏度过高（Viscosity）
  * 难以做正确的事情



面向对象设计复用的目标在于**实现支持可维护性的复用**



### 七大原则

* 单一职责原则  Single Responsibility Principle
  * 类的职责单一，不能将太多的职责放在一个类中
* 开闭原则  Open-closed Principle
  * 软件实体对扩展是开放的，但对修改是关闭的，即在不修改一个软件实体的基础上去扩展该功能
* 里氏替换原则  Liskov Substitution Principle
  * 在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象
* 依赖倒置原则  Dependency Inversion Principle
  * 要针对抽象层编程，而不是针对具体类编程
* 接口隔离原则  Interface Segregation Principle
  * 使用多个专门的接口来取代一个统一的接口
* 合成复用原则  Composite Reuse Principle
  * 在系统中应该尽量多使用组合和聚合关联关系，尽量少使用甚至不使用继承关系
* 迪米特法则  Law of Demeter
  * 一个软件实体对其他实体的引用越少越好，或者说如果有两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，而是通过引入一个第三者发生间接交互



## 单一职责原则

### 单一职责原则分析

* 就一个类而言，应该有且仅有一个引起它变化的原因

* 一个类（或者大到模块，小到方法），承担的职责越多，它被复用的可能性越小
* 类的职责包括两个方法
  * 数据职责 （属性）
  * 行为职责 （方法）
* 高内聚，低耦合



### 开闭原则

* 抽象化是开闭原则的关键
* 开闭原则还可以通过一个更加具体的“对可变性封装原则”来描述，对可变性封装原则（Principle of Encapsulation of Variation）要求找到系统的可变因素并封装起来

* 两个类之间互相依赖是不稳定的，不符合开闭原则
  * 如果在这两个类中增加一个接口或抽象类，（抽象是稳定的），那么现在如果想要一个新的功能，只需要扩展该接口或抽象类，再派生一个类即可



### 里氏替换原则

* 所有引用基类的地方必须能**透明**地使用其子类对象（即改变之后程序行为不变）
* 当调用一个派生类上的方法时造成了非法使用，就违反了LSP原则，如果使用了一个退化的派生类方法（即什么也没实现），也违反了LSP。此时，说明该派生类是没有意义的



### 依赖倒置原则

* 高层模块不应该依赖于低层模块，都应该依赖抽象
* 抽象不应该依赖细节，细节应该依赖抽象
* 如果说开闭原则是面向对象设计的目标的话，那么依赖倒置原则就是面向对象设计的主要手段
* “将抽象放进代码，将细节放进元数据”
* 类之间的耦合关系
  * 零耦合关系
  * 具体耦合关系
  * 抽象耦合关系（推荐）
* 依赖注入
  * 更好地实现依赖倒置原则
  * 构造注入  Constructor Injection
  * 设值注入  Setter Injection
  * 接口注入  Interface Injection



### 接口隔离原则

* 客户端不应该依赖那些它不需要的接口
* 一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可
* 一个接口只代表一个角色（角色隔离原则）
* 使用接口隔离原则拆分接口时，首先必须满足**单一职责原则**，将一组相关操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好
* 可以在进行系统设计时采用**定制服务**的方式，即为不同的客户端提供宽窄不同的接口，只提供用户需要的行为，而隐藏用户不需要的行为



### 迪米特法则

* 又叫最少知识原则

  * 不要和“陌生人”说话
  * 只与你的直接朋友通信
  * 每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位

* 一个软件实体应当尽可能少的与其他实体发生互相作用

  * 这样，一个模块修改时，就会尽量少的影响其他模块，扩展会相对容易，这就是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度

* 对于一个对象，其朋友包括

  * 当前对象this
  * 以参数形式传入到当前对象方法中的对象
  * 当前对象的成员对象
  * 如果当前对象的成员对象是一个集合，那么集合中的元素也是朋友
  * 当前对象所创建的对象

* 狭义的迪米特法则

  ```
  可以降低类之间的耦合，但是会在系统中增加大量的小方法并散落在系统的各个角落，它可以使一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联，但是也会造成系统的不同模块之间通信效率降低，使得系统的不同模块之间不容易协调
  ```

* 广义的迪米特法则

  ```
  指对对象之间的信息流量、流向以及信息的影响的控制，主要是对信息隐藏的控制。信息的隐藏可以使各个子系统之间脱耦，从而允许它们独立地被开发、优化、使用和修改，同时可以促进软件的复用，由于每一个模块都不依赖于其他模块而存在，因此每一模块都可以独立地在其他地方使用。一个系统的规模越大，信息的隐藏就越重要，而信息隐藏的重要性也越明显。
  ```

* 分析

  * 在类的划分上，尽量创建松耦合的类
  * 在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限
  * 在类的设计上，只要有可能，一个类型应该设计为不变类
  * 在对其他类的引用上，一个对象对其他对象的引用应当降低到最小

适用设计模式：

* 外观模式
* 中介者模式



### 合成复用原则

* 又叫组合/聚合复用原则
* 尽量使用对象组合聚合（黑箱复用），而不是继承（白箱复用）来达到复用的目的
  * 继承复用：实现简单，易于扩展；破坏系统的封装性，从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性，只能在有限的环境中使用
  * 组合/聚合复用：耦合度相对较低，选择性地调用成员对象的操作，可以在运行时动态进行



### 一个类如何设计

* 单一职责原则
* 开闭原则



### 两个类如何设计

* 迪米特法则（两个类最好不要发生关系）
* 依赖倒置原则（要依赖抽象）
* 接口隔离原则（仅依赖自己需要的）
* 合成复用法则

* 里氏替换原则