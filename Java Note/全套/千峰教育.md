# 千峰教育
## 一、基础
### 1、递归
* 实际开发中，递归可以解决具有既定规律的特定问题
* 何时使用递归？
    * 当需要解决的问题可以拆分成若干个小问题，大小问题的解决办法相同（精华）
    * 有固定规律，函数中自己调用自己
* 如何正确使用递归？
    * 设置有效的出口条件，避免无穷递归
* 递归分为递进和回归
    * 递进：每一次推进，计算都比上一次变得简单，直到简单到无需继续推进，就能获得结果。也叫到达出口。
    * 回归：基于出口的结果，逐层向上回归，依次计算每一层的结果，直至回归到最顶层
* 注意：所有能以递归解决的问题都可以用循环解决。但是递归的代码往往会更简单
### 2、数组
#### 数组的概念
* 一组连续的存储空间，存储多个相同的数据类型的值
* 特点：
    * 类型相同
    * 长度固定
* 数组下标越界异常是运行时异常ArrayIndexOutOfBoundsException
* 数组创建时有默认值，与该类型作为成员变量时的默认值相同
#### 数组的操作
1. 复制与扩容
    * 采用循环将原数组所有元素注意赋值给新数组
    * 使用System类提供的方法System.arraycopy(原数组，原数组起始位置，新数组，新数组起始，要复制的数组元素的数量)
    * 使用java.util.Arrays中的copyOf(oldArray, newArrayLength)方法，返回一个长度为newArrayLength新数组，对于新数组和oldArray都具有的索引，两个数组在该索引上的值相同，如果newArray比oldArray长度要长，则多余部分用该数组的默认值进行填充
#### 可变长参数
* 可接收多个同类型实参，个数不限，使用方式与数组相同
* 语法： 数据类型... 形参名
* 必须是参数的最后一个，且可变长参数只能有一个

### 3.接口
* 微观：接口是一种能力与约定
* 宏观：接口是一种标准
#### 常量接口
* 将多个常用于表示状态或固定值的变量，以静态常量的形式定义在接口中统一管理，提高代码的可读性
#### 枚举enum
* 规范取值的类型
#### 接口回调
* 先有接口标准，再有接口的使用者，最后是接口的实现者
#### 接口的好处
* 程序的耦合度降低
* 更自然地使用多态
* 设计（接口）与实现完全分离
* 更容易搭建程序框架
* 更容易更换具体实现

### 4.Objects
#### getClass()方法
* 返回该对象引用中的实际存储的对象的类型
* 应用：
    * 反射
    * 判断两个引用的指向的对象的类型是否相同
#### hashCode()方法
* 返回对象的地址的十进制表现形式
#### toString()方法
* return getClass().getName() + "@" + Integer.toHexString(hashCode());
#### equals(Object o)方法
* return this == o;
* 比较两个对象的内存地址是否相同
* 可以进行覆盖，用来比较两个对象的内容（属性）否都相同
* 覆盖步骤
    1. 比较两个引用是否指向同一个对象，如果是直接返回true
    2. 判断obj是否为null（注意：null instanceof 类型结果为false。如果第三步判断的方法使用instanceof可以省略第二步，如果是getClass，则不能省略）
    3. 判断两个引用指向的实际对象类型是否一致
    4. 强制类型转换
    5. 依次比较各个属性值是否相同
#### finalize()方法
* 当对象被判定为垃圾对象时，由JVM自动调用该方法，用以**标记垃圾对象，进入回收队列**
* 垃圾对象： 没有有效引用指向此对象（可达性分析算法）
* 垃圾回收： 由GC销毁垃圾对象，释放数据存储空间
* 自动回收机制： JVM内存耗尽，一次性回收所有垃圾对象
* 手动回收机制： 使用System.gc()；通知JVM执行垃圾回收（不要频繁的手动执行gc，会占用大量的资源）
* 注意：不恰当的finalize的使用会造成内存泄漏，不建议使用（自动内存管理已经很完善了）

### 5.包装类
* 自动装箱
    * Byte b = 10;
    * JVM自动调用valueOf(byte b)方法
* 自动拆箱
    * b = new Byte(10);
    * JVM自动调用byteValue()方法
* 整数数据缓存
    * 对于自动装箱来说，底层调用的是包装类的valueOf方法，每一个整数包装类里面都有一个私有静态的内部类作为缓存，比如Short的缓存是ShortCache
    * 每一个整数缓存类都有一个数组，且数组封装了本类对象，范围从-128到127（byte范围），因为这个范围的数字会经常使用，为了提高程序效率，将其进行缓存
    * 对于这个范围的数字，valueOf方法直接返回对象
    * 注意：在JDK9以后，数字包装类的构造方法被弃用，推荐使用valueOf方法，因为其效率更高（使用缓存匹配byte范围的数字）

### 6.String

>  字符串如果使用字面值的形式创建，其引用的地址是字符串常量池的地址
>
> 字符串如果使用new创建对象的方式创建，其引用的地址是堆内的地址

* JDK5-8对于字符串连接的优化是JVM在底层创建StringBuidler对象，拼接字符串之后使用toString()方法返回结果
* 在JDK9之后使用InvokeDynamic动态调用，在运行过程中动态调用指令进行字符串的拼接
* 注意：String不仅覆盖了Object类中的equals方法，还覆盖了hashCode方法，返回`s[0] * 31^(n-1) + s[2] * 31^(n-2) + ... + s[n-1] * 31`^0`

### 7.Big Decimal

* 由于浮点数在内存中的存储格式问题，一些对于浮点数的操作不是很精确
* 作用：Big Decimal提供了精确的计算浮点数，通过类中的方法add，subtract，multiply，divide等方法
* 如果要精确构建小数，通过Big Decimal创建，构造方法需要传入String形式的数字
* 注意：对于除法来说，divide方法如果只传入一个除数的话，会产生算术异常，因为除不尽。所以需要传入`保留的小数位`以及`四舍五入的规则`（该规则作为常量在Big Decimal中，一般使用ROUND_HALF_UP，四舍五入）

### 8.Collection集合

#### 8.1 ArrayList

* 使用空参构造方法创建List，默认创建一个空的链表，但是会在第一次add元素的时候，将底层数组扩容至`default size10`，这是顾及到创建ArrayList却没有使用的场景，也是JDK的优化
* 正常情况下，底层数组每次扩容至`oldSize + oldSize / 2`，即原来大小的1.5倍
* 特点： 数组结构实现，查询快、增删慢

#### 8.2 HashSet

* 集合中的元素是无序的，不可重复的
* HashSet保证元素唯一性的方法
  * 通过元素的hashCode()方法和equals()方法
  * 如果对象的hashCode相同，则需要调用equals()方法，又为true的话，则两个比较的对象相同
  * 如果hashCode不同，则不需要调用equals()方法，两个对象肯定不同（如果直接调用equals方法，则元素越多增加新元素时比较的次数也越多，list不需要在增加时进行比较）
  * 注意：对于ArrayList来说，由于允许存入多个相同的对象，所以不需要比较对象的hashCode()方法，在remove元素的时候，只需要比较equals方法

#### 8.3 TreeSet

>TreeSet 要求保存的类型实现Comparable接口
>
>或者是在创建集合的时候传入一个Comparator

* TreeSet保证元素唯一性的方法
  * 通过保存的类型的compareTo()方法或者是compare()方法
  * 在每次加入新元素的时候，将新元素与每个已加入的元素进行比较，调用compareTo()方法，如果返回0，则新元素添加失败；同时还为新元素进行排序处理

#### 8.4 Map

> 键不允许重复

* HashMap: JDK1.2，线程不安全，运行效率；允许用null作为key或value（初始容量16，加载因子0.75）
* Hashtable: JDK1.0，线程安全，运行效率慢；不允许null作为key或者value（初始容量11，加载因子0.75）
* Map添加相同键，value会进行覆盖

> HashMap的底层使用的是一个类型为Map.Entry<K, V>的数组，采用链表发进行存储

* Properties： 没有泛型，存储的键值都是String类型。（此类在设计上存在瑕疵，原因是继承了一个泛型类，导致在put方法中的参数是Object类型的，无法进行类型控制）
  * 存储键值：setProperty(String key, String Value)
  * 取出值： getProperty(String key)
* TreeMap



### 9. 泛型集合

* 参数化类型、类型安全的集合，强制集合元素的类型必须一致
* 特点
  * 编译时即可检查，而非运行时抛出异常
  * 访问时，不必进行类型转换
  * 不同泛型之间引用不能互相赋值，泛型不存在多态（non-variant）
* 实例泛型： 泛型在创建类上
* 静态泛型： 泛型在静态方法上，可以使用泛型限定来控制参数表接收的类型
* 泛型限定

### 10. 方法运行时的栈帧结构

* 程序计数器： 保存下一条需要操作的指令
* 局部变量表： 用数组保存局部变量

* 操作数栈： 将当前指令中操作的引用数据类型的地址或者基本数据类型压栈或出栈

#### 10.1 异常流程与方法栈的关系（偏，面试可能会问）

```java
	    int a = 10;
        try {
            a = 20;
            throw new RuntimeException();
        } catch (Exception e) {
            a = 30;
            return a;
        } finally {
            a = 40;
        }
```

> 由于在执行catch代码块中的return语句之前需要执行finally语句
>
> 程序先将需要返回的值保存在局部变量表的一个新的空间中
>
> 最后等finally执行完毕，将局部变量表的返回值空间中的值进行返回
>
> 返回结果是： 30

### 11. 多线程

#### 11.1 线程的组成

* CPU时间片： 操作系统（OS）会为每个线程分配执行的操作时间
* 运行数据：（堆空间共享，栈空间独立）
  * 堆空间：存储线程需使用的对象，多个线程可以共享堆中的对象
  * 栈空间：存储线程需使用的局部变量，每个线程都拥有独立的栈
* 线程的逻辑代码

### 12. IO流

#### 12.1 ObjectOutputStream/ObjectInputStream

* 增强了缓冲区功能
* 增强了读写8种基本数据类型和字符串功能（字符串通过writeUTF()，只支持UTF8的编码格式）
* 增强了读写对象的功能
  * readObject()：反序列化
  * writeObject()：序列化
* 对象序列化的细节
  * 必须实现Serializable接口
  * 必须保证其所有属性均可序列化
  * transient修饰为临时属性，不参与序列化
  * 读取到文件尾部的标志：java.io.EOFException

#### 12.2 File

* File[] listFiles(): 如果当前文件不是目录返回null；如果当前文件是目录，返回目录下所有文件及文件夹的File对象
* File[] listFiles(FileFilter filter): 如果当前File对象是目录，则返回所有满足filter的accept方法返回true的文件或文件夹的File对象；如果不是目录，返回null
* FileFilter： 是一个接口，对于符合一定条件（子类定义）的File对象，返回true，实现过滤文件的效果

```java
public interface FileFilter {
	boolean accept(File file);
}
```



### 13. 网络编程

* 让计算机之间`建立连接`，`进行通信`

#### 13.1 TCP开发步骤

* 建立通信连接（会话）
  * 创建ServerSocket，指定端口号
  * 调用accept等待客户端接入
* 客户端请求服务器
  * 创建Socket，指定服务器IP+端口号
  * 使用输出流，发送请求数据给服务端
  * 使用输入流，接收响应数据给客户端
* 服务器响应客户端
  * 使用输入流，接收请求数据到服务端
  * 使用输出流，发送响应数据到客户端

### 14. 反射Reflection

#### 14.1 Class类对象

* 类对象：类加载的产物，封装了一个类的所有信息（类名，父类，接口，属性，方法，构造方法）



1）在源代码阶段（javac编译生成字节码文件）

​	  Class.forName(“全类名”)：将字节码文件加载进内存，返回class对象

​     多用于配置文件，将类名定义在配置文件中。读取文件，加载类

2） 在内存阶段（Class类对象阶段）

​	 类名.class：通过类名的属性class获取

​     多用于参数的传递

3） 在对象阶段（Runtime运行阶段）

​	 对象.getClass()：getClass()方法定义在Object类中

​     多用于对象的获取字节码的方式

#### 14.2 常用方法

* getFields：返回本类及所有继承的父类的public修饰符修饰的属性
* getDeclaredFields：返回本类的所有属性
* getField(String fieldName)：返回fieldName对应的public修饰的属性
* getDeclaredField(String fieldName)：返回fieldName对应的属性
* getMethods：返回本类及所有继承的父类的public修饰符修饰的方法（不包括静态方法）
* getDeclaredMethods：返回本类的所有方法
* getMethod(String methodName)：返回methodName对应的public修饰的方法
* getDeclaredMethod(String methodName)：返回methodName对应的方法
* getConstructors：返回本类的所有public的构造方法
* getDeclaredConstructors：返回本类的所有构造方法
* getConstructor(Class... parameterTypes)：返回与指定类型匹配的public修饰的构造方法
* getDeclaredConstructor(Class... paramterTypes)：返回与指定类型匹配的构造方法

对于Method对象，可以调用invoke(Object obj, Object... args)，通过对象obj调用该方法并传入args参数

对于Field、Method、Constructor对象，可以通过setAccessible(true)将属性设置为可访问的，然后通过这些对象进行设置

对于Constructor对象，可以通过newInstance(Object... args)方法创建对象（原来的通过class对象创建实例已经被弃用了）

### 15. 内部类

#### 15.1 特点

* 编译之后生成独立的字节码文件
* 内部类可直接访问外部类的私有成员，而不破坏封装
  * 持有一个 `[外部类].this` 引用
* 可为外部类提供必要的内部功能组件

#### 15.2 成员内部类

* 外部类的实例部分，创建内部类对象，必须依赖外部类对象

```java
Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();
```

* 不可以定义静态属性

#### 15.3 静态内部类

* 不依赖外部类对象，可以直接创建或通过类名访问，可声明静态成员
* 只能直接访问外部类的静态成员（实例成员需实例化外部类对象）

#### 15.4 局部内部类

* 定义在外部类的方法中，作用范围和创建对象范围仅在当前方法内部
* 局部内部类访问外部类当前方法中的局部变量时，因无法保障变量的生命周期与自身相同，变量必须修饰为final

含有局部内部类的方法吧被调用结束之后，局部变量会被释放，但是方法内部创建的局部内部类的对象如果仍然有引用指向它，是可以继续使用的。用final修饰局部变量可以延长局部变量的生命周期，至少会比当前内部类的对象的生命周期长，不会存在访问不到的问题。

* 限制类的使用范围



***



## 二、Mysql

### 数据库基本概论

#### 1、SQL（Structured Query Language）语句分类

* DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等
* DML（Data Manipulation Language)：数据操作语言，用来定义数据库记录（数据）`增、删、改`
* DCL（Data Control Language)：数据库控制语言，用来定义访问权限和安全级别
* DQL（Data Query Language）：数据查询语言，用来查询记录（数据）

#### 2、Mysql注释

```sql
1. 以#开头
	#这是一张student表
2. --空格开头
	-- 这是一张student表
3. /* 多行注释 */
	/*
	这是一张student表
	*/
```

#### 3、DDL操作数据库

##### show databases

查看所有的数据库

```sql
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| blog               |
| company_authority  |
| information_schema |
| mysql              |
| performance_schema |
| shop               |
| sys                |
| test               |
| tianmu             |
+--------------------+
9 rows in set (0.00 sec)
```

**系统默认数据库：**

information_schema

```
information_schema数据库是MySql自带的，提供了访问数据库元数据的方式。
元数据是关于数据的数据，如数据库名称、表名、列的数据类型、或访问权限等
```

mysql

```j
mysql的核心数据库，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息
```

performance_schema

```
性能优化的数据库
```

##### 创建数据库

```sql
CREATE DATABASE [IF NOT EXISTS] db_name;
```

创建一个数据库mydb1并且字符集是gbk

```sql
CREATE DATABASE IF NOT EXISTS mydb1 CHARACTER SET GBK;
```

##### 查看数据库

查看数据库创建信息

```sql
SHOW CREATE DATABASE mydb1;
```

查看当前使用的数据库

```sql
SELECT database();
#如果没有选择数据库，返回null
```

##### 修改数据库

修改数据库字符集

```sql
ALTER DATABASE mydb1 CHARACTER SET utf8;
```

##### 删除数据库

```sql
DROP DATABASE IF EXISTS mydb1;
```

##### 切换数据库

```sql
use mydb1;
```

#### 4、DDL操作表

##### 创建表

```sql
CREATE TABLE [IF NOT EXISTS] 表名(
	字段1  字段类型(长度)  约束,
    字段2  字段类型(长度)  约束,
    ...
    字段n  字段类型(长度)  约束
) [charset=utf8];
```

##### 约束

主键约束：primary key（保证数据的唯一性），不能重复，不能为null

唯一约束：unique，不能重复

非空约束：not null

默认约束：default

外键约束：default

自动增长：auto_increment

##### 删除表

```sql
DROP TABLE table_name;
```

##### 查看表

```sql
SHOW TABLES;
```

查看表的字段信息

```sql
DESC user;

#运行结果
mysql> desc user;
+----------+--------------+------+-----+---------+----------------+
| Field    | Type         | Null | Key | Default | Extra          |
+----------+--------------+------+-----+---------+----------------+
| id       | int(11)      | NO   | PRI | NULL    | auto_increment |
| username | varchar(32)  | NO   |     | NULL    |                |
| birthday | datetime     | YES  |     | NULL    |                |
| sex      | char(1)      | YES  |     | NULL    |                |
| address  | varchar(256) | YES  |     | NULL    |                |
+----------+--------------+------+-----+---------+----------------+
5 rows in set (0.01 sec)
```

##### 修改表

增加列

```sql
ALTER TABLE 表名 ADD 新列名 字段类型 约束;
```

修改列

```sql
ALTER TABLE 表名 MODIFY 列名 新的字段类型 新约束;
```

删除列

```sql
ALTER TABLE 表名 DROP 列名;
```

修改表名

```sql
RENAME TABLE 表名 TO 新表名; 
```

查看表的创建语句

```sql
SHOW CREATE TABLE user;
```

修改字符集

```sql
ALTER TABLE 表名 CHARACTER SET 字符集名;
```

修改列名(同时需指定新列名的字段类型和约束)

```sql
ALTER TABLE 表名 CHANGE 列名 新列名 字段类型 约束;
```

#### 5、DML操作

##### 插入操作

```sql
INSERT INTO 表名(列名1,列名2,...)
values
(列值1,列值2...),
(列值1,列值2...),
...
(列值1,列值2...);
```

##### 小知识：查看并临时修改数据库编码信息

查看数据库编码

```sql
show variables like 'character%';
```

临时修改客户端和服务端结果集编码

```sql
Set character_set_client=gbk;
Set character_set_server=gbk;
```

或者

```sql
SET NAMES 'gbk';  //client connection results
```

##### 修改操作

```sql
UPDATE 表名 
SET 列名1=列值1 列名2=列值2 ... 
WHERE 列名=值;
#不加where子句则对表的所有数据生效
```

##### 删除操作

```sql
DELETE FROM 表名 [WHERE 列名=列值];
```

清空数据(先把表删除，并创建相同结构的空表)

```sql
TRUNCATE TABLE 表名;
```

#### 6、DQL操作

```sql
SELECT 列名1,列名2,...			/*要查询的列*/
FROM 表名						 /*要查询的表*/	
WHERE condition				  /*行条件*/
GROUP BY grouping_columns	  /*对结果分组*/
HAVING condition			  /*分组后的行条件*/
ORDER BY sorting_columns	  /*对结果排序*/
LIMIT offset_start, row_count /*结果限定*/
```

执行顺序：from --> where --> group by --> having --> select --> order by --> limit

##### 模糊查询

```sql
关键字 like
_ 表示任意一个字符
% 表示任意0~n个字符
```

##### 字段控制查询

1）去除重复记录：DISTINCT

保留第一个出现的

2）对null值进行运算的结果还是null

如果想要将null作为0来处理，可以使用`IFNULL(字段， 0)`

3）字符串合并：concat(字段1， 字段2， ..., 字段n)

##### 聚合函数

* COUNT()
* MAX()
* MIN()
* SUM()
* AVG()

null不参与运算，如果参与，作为0处理

##### LIMIT限制

查询emp表，返回结果集的第1行开始，返回3行

```sql
SELECT * FROM emp LIMIT 0,5;
```

#### 7、数据完整性

##### 实体完整性

* 主键

```sql
-- 创建主键
#1
create table stu(
	id int primary key
);

#2
create table stu(
	id int,
	primary key(id)
);

#3
ALTER TABLE stu ADD CONSTRAINT primary key(id);
```

* 唯一约束（unique）
* 自动增长列（auto_increment）

sqlserver(identity) oracle(sequence)

自动增长不能单独使用，一般需要和主键配合

列只能是数值类型，默认增量为1

```sql
create table stu(
	id int primary key auto_increment,
    sname varchar(50)
)auto_increment=100;
#从101开始自增，增量为1
```

* 默认值约束（default）

##### 参照完整性

* 外键

```sql
create table score(
	id int,
	score int,
	constraint fk_score_sid foreign key(sid) references stu(id)
);
```

#### 8、多表关系

##### 一对多关系

在多的一方创建一个字段，字段作为外键指向一方的主键

##### 多对多关系

需要创建第三张中间表，中间表至少两个字段，分别作为外键指向各自一方的主键

##### 一对一关系

#### 9、多表查询

##### 合并结果集

UNION，UNION ALL

合并的两个表的结果集必须列数相同

##### 内连接

```sql
SELECT * FROM emp e 
INNER JOIN dept d
ON e.deptno = d.deptno;
```

##### 外连接

左外连接

先查左表，再向右表匹配，如果没有满足的，显示null

```sql
SELECT * FROM emp e 
LEFT OUTER JOIN dept d
ON e.deptno = d.deptno;
```

右外连接

```sql
SELECT * FROM emp e 
RIGHT OUTER JOIN dept d
ON e.deptno = d.deptno;
```

##### 子查询

* 子查询出现的位置
  * where子句：作为被查询条件的一部分
  * from子句：作为临时表
* 当子查询出现在where子句之后，还可以使用
  * any关键字（多行单列）
  * all关键字（多行单列）

* 子查询结果集的常见形式
  * 单行单列：用于条件
  * 多行单列：用于条件
  * 多行多列：用于临时表

#### 10、事务

>数据库事务（Database Transaction），是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。

##### 事务的ACID特性

原子性A （Atomicity），一致性C （Consistent），隔离性I （Isolation），持久性D （Durabilty）

##### 事务开始

* 连接到数据库，并执行一条DML语句insert、update或delete
* 前一个事务结束后，又输入一条DML语句

##### 事务结束

* 执行commit或rollback语句
* 执行一条DDL语句，比如建表语句，会自动执行commit语句
* 执行一条DDL语句，比如grant语句
* 断开数据库语句
* 执行一条DML语句但是失败了，会自动执行rollback语句

##### 事务执行的步骤

```sql
#1、开启事务
start transaction;
#2、事务内数据操作语句
insert
update
#3、提交事务
COMMIT;
#4、回滚事务
ROLLBACK;
```

#### 11、常用函数

##### 1、CURDATE()

获取当前日期

##### 2、CURTIME()

获取当前时间

##### 3、Now()

获取当前日期和时间

##### 4、WEEK(date)

返回日期date是一年当中的第几周

##### 5、YEAR(date)

返回日期date的年份

##### 6、HOUR(time)

返回时间time的小时值

##### 7、MINUTE(time)

返回时间time的分钟值

##### 8、DATEDIFF(date1, date2)

返回日期参数date1和date2之间相隔的天数

##### 9、ADDDATE(date, n)

计算日期参数date加上n天后的日期

##### 10、CONCAT(str1, ..., strn)

连接n个字符串

##### 11、INSERT(str, pos, len, newStr)

字符串替换，将str中从pos开始len个字符替换成newStr

下标从1开始

##### 12、LOWER(str)和UPPER(str)

将字符串转为小写/大写

##### 13、SUBSTRING(str, num, len)

将字符串strnum开始len个字符截取出来

#### 11、导出导入数据库

导出数据库

```sql
mysqldump -uroot -p 数据库名 > school.sql
```

导入数据库表

```sql
source d:/school.sql
```

重复的table名不会进行覆盖

#### 12、创建用户和授权

##### 创建用户

```sql
#		     账号						密码
CREATE USER `zhangsan` IDENTIFIED BY '123';
```

##### 授权

```sql
GRANT ALL ON school.* TO `zhangsan`;
```

##### 撤销权限

```sql
REVOKE ALL ON school.* FROM `zhangsan`;
```

##### 删除用户

```sql
DROP USER `zhangsan`;
```

#### 13、视图

视图创建

```sql
create view 视图名
as
查询语句;
```

注意：

> 如果视图包含以下结构中的任何一种，则该视图不可更新
>
> 聚合函数
>
> group by
>
> distinct
>
> having
>
> union、union all
>
> from子句中的不可更新的多个表
>
> where子句的子查询，引用from子句的表

##### 视图的修改

方式一

```sql
create or replace 视图名
as
查询语句;
```

方式二

```sql
alter view 视图名
as
查询语句;
```

##### 删除视图

```sql
drop view 视图名;
```



### JDBC

#### 1、JDBC的使用步骤

```java
	// 1.注册驱动程序（Driver类中的static代码块会在类加载的时候将驱动程序注册）
    try {
        Class.forName("com.mysql.cj.jdbc.Driver");
    } catch (ClassNotFoundException e) {
        System.out.println("驱动类不存在");
    }

    Connection conn = null;
    Statement statement = null;
    ResultSet result = null;
    try {
        // 2、创建连接
        conn = DriverManager.getConnection(url, name, password);

        // 3、创建语句
        statement = conn.createStatement();

        // 4、执行sql
        String sql = "select * from user";
        result = statement.executeQuery(sql);

        // 5、处理结果集
        List<User> users = new ArrayList<>();
        while (result.next()) {
            User user = new User(result.getInt(1), result.getString(2),
                                 result.getDate(3), result.getString(4), result.getString(5));
            users.add(user);
        }
        return users;
    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
        // 6、释放资源
        try {
            if (result != null)
                result.close();
            if (statement != null)
                statement.close();
            if (conn != null)
                conn.close();
        } catch (SQLException e) {
            System.out.println("关闭资源失败");
        }
    }
	return null;
```

* boolean execute(String sql) ：如果检索到ResultSet对象，则返回一个布尔值true；否则返回false。使用此方法执行除了DQL之外的语句
* int executeUpdate(String sql)：返回受SQL语句执行影响的行数。一般用来执行增删改
* ResultSet executeQuery(String sql)：返回一个ResultSet对象。执行DQL语句

##### 解决SQL注入

```java
 		// 2、创建连接
        Connection conn = DriverManager.getConnection(url, name, password);

        // 3、创建语句，并进行预编译
        String sql = "select * from user where username = ? and password = ?";
        PreparedStatement statement = conn.preparedStatement(sql);

		// 4、填充占位符
		statement.setObject(1, "zhangsan");
		statement.setObject(2, "123456");

        // 5、执行sql
        ResultSet result = statement.executeQuery();
```

##### 重用性

将一些重复率高的代码进行封装

工具类DBUtils

1.注册驱动  2.获取连接  3.释放资源

```java
public class DBUtils {
    
    private static String driver;
    private static String url;
    private static String username;
    private static String password;

    private DBUtils() {}
    
    static {
        Properties props = new Properties();
        try {
            // 加载配置文件
            props.load(DBUtils.class.getResourceAsStream("db.properties"));
            driver = props.getProperty("driver");
            url = props.getProperty("url");
            username = props.getProperty("username");
            password = props.getProperty("password");
            
            // 注册驱动
            Class.forName("com.mysql.cj.jdbc.Driver");
        } catch (IOException | ClassNotFoundException e) {
            throw new RuntimeException(e);
        }

    }
    
    // 获取连接
    public static Connection getConnection() {
        try {
            return DriverManager.getConnection(url, username, password);
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    // 释放资源
    public static void close(ResultSet resultSet, Statement statement, Connection conn) {
        try {
            if (resultSet != null) resultSet.close();
            if (statement != null) statement.close();
            if (conn != null) conn.close();
        } catch (SQLException e) {
            System.out.println("关闭资源失败");
        }

    }
}
```

#### 2、DAO模式

##### ORM思想

将数据库映射到Java的实体对象

##### DAO设计模式

DAO（Data Access Object）

* DAO的组成部分

  * DAO接口
  * DAO实现类
  * 实体类（domain,beans,entity,pojo,model）
    * 属性私有
    * 提供public的getter和setter
    * 实体类提供无参构造，根据业务提供有参构造
    * 实现java.io.Serializable接口，实现序列化

  * 工具类utils

#### 3、Druid连接池

##### 1、配置文件database.properties

```properties
#连接设置
driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/database?serverTimezone=GMT%2B8&characterEncoding=utf-8
username=root
password=123456

#初始化连接
initialSize=10
#最大连接
maxActive=50
#最小空闲连接
minIdle=5
#超时等待时间（以毫秒为单位）
maxWait=5000
```

2、Druid的使用

导入jar包

创建连接池

```java
public class DruidUtils {
    private static DruidDataSource dataSource;
    private static Connection conn;

    static {
        Properties props = new Properties();
        try {
            props.load(ClassLoader.getSystemResourceAsStream("database.properties"));

            // 创建连接池
            dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(props);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

```

注意：通过连接池获取的连接，同一个账号和密码在一次运行程序中获取的是同一个连接

所以最好不要关闭连接

##### 2、使用ThreadLocal解决事务

对于事务来说，其操作须符合原子性，即要么全都完成，要么全都不做

开启事务

```java
connection.setAutoCommit(false);
```

提交事务

```java
connection.commit();
```

回滚事务

```java
connection.rollback();
```

为了使事务内所有对数据库的操作的连接是同一个，需要使用**ThreadLocal**类来解决这个问题

```java
ThreadLocal类
    // get方法，取到与当前线程绑定的value
    // 如果不存在，返回null
    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }

	// set方法
	// 将value绑定到当前线程
	public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            map.set(this, value);
        } else {
            createMap(t, value);
        }
    }

	// remove方法
	// 清空与当前线程绑定的value
	public void remove() {
         ThreadLocalMap m = getMap(Thread.currentThread());
         if (m != null) {
             m.remove(this);
         }
     }
```

##### 3、带有事务的工具类DruidUtils

带有事务的DruidUtils

```java
package cn.zhanguozhi.utils;

import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.pool.DruidDataSourceFactory;

import javax.sql.DataSource;
import java.io.IOException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

/**
 * 使用了Druid连接池的工具类
 */
public class DruidUtils {
    private static DruidDataSource dataSource;
    private static Connection conn;
    private static ThreadLocal<Connection> threadLocal = new ThreadLocal<>();
    static {
        Properties props = new Properties();
        try {
            props.load(ClassLoader.getSystemResourceAsStream("database.properties"));

            // 创建连接池
            dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(props);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }



    public static DataSource getDataSource() {
        return dataSource;
    }

    public static Connection getConnection() {
        try {
            if (conn == null) {
                threadLocal.set(dataSource.getConnection());
            }
            conn = threadLocal.get();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return conn;
    }

    public static void close(ResultSet resultSet, Statement statement, Connection conn) {
        try {
            if (resultSet != null) resultSet.close();
            if (statement != null) statement.close();
            if (conn != null) {
                conn.close();
                threadLocal.remove();
                conn = null;
            }
        } catch (SQLException e) {
            System.out.println("关闭资源失败");
        }

    }

    // 开启事务
    public static void startTx() throws SQLException {
        conn = getConnection();

        if (conn != null) {
            conn.setAutoCommit(false);
        }
    }

    // 提交事务
    public static void commitTx() throws SQLException {
        conn = getConnection();

        if (conn != null) {
            conn.commit();
        }
    }

    // 回滚事务
    public static void rollbackTx() throws SQLException {
        conn = getConnection();

        if (conn != null) {
            conn.rollback();
        }
    }
}
```

##### 4、通用的增删改方法

```java
public static int executeUpdate(String sql, Object... args) throws SQLException {
        conn = getConnection();
        PreparedStatement ps = null;
        try {
            ps = conn.prepareStatement(sql);
            for (int i = 0; i < args.length; i++) {
                ps.setObject(i + 1, args[i]);
            }
            return ps.executeUpdate();
        } finally {
            close(null, ps, null);
        }
    }
```

##### 5、通用的查询方法

```sql
public static <T> List<T> executeQuery(String sql, RowMapper<T> rowMapper, Object... args) throws SQLException {
        conn = getConnection();
        PreparedStatement ps = null;
        ResultSet rs = null;
        List<T> res = new ArrayList<>();
        try {
            ps = conn.prepareStatement(sql);
            for (int i = 0; i < args.length; i++) {
                ps.setObject(i + 1, args[i]);
            }
            rs = ps.executeQuery();
            while (rs.next()) {
                res.add(rowMapper.getRowMapper(rs));
            }
        } finally {
            close(rs, ps, null);
        }
        return res;
    }
    
    
/**
 * 行映射器
 * 做结果集到对象的映射
 */
public interface RowMapper<T> {

    T getRowMapper(ResultSet rs) throws SQLException;

}

/**
 * User的行映射器
 */
public class UserRowMapper implements RowMapper<User> {
    @Override
    public User getRowMapper(ResultSet rs) throws SQLException {
        return new User(rs.getInt(1), rs.getString(2),
                rs.getDate(3), rs.getString(4), rs.getString(5));
    }
}
```

#### 4、Apache的DBUtils

DBUtils：启动类

ResultSetHandler接口：转换类型接口，封装结果集的结果的对象

​	ArrayHandler类：将记录转为数组

​	ArrayListHandler类：将记录转为数组，并放入集合中

​	ColumnListHandler类：取某一列的数据，封装到List中

​	**ScalarHandler**类：适合获取一行一列的数据（一般是聚合函数）

​	**BeanHandler**类：把记录转为对象

​	**BeanListHandler**类：把记录转为对象，放入集合

QueryRunner类：执行SQL语句

```sql
每一个Dao类
private QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource());
```



## 三、HTML

### frameset框架标签

```html
<!--
	frameset标签
		rows代表按行分割
		border设置边框
	frame标签
		noresize设置是否可以改变页面大小
		scrolling是否显示滚动条
			yes 显示  no  不显示  auto  如果内容高度超过屏幕直接显示滚动条
		src设置填充的页面
备注：
	frameset和body不能同时出现

-->
<frameset rows="20%, *" frameborder="1" border="5">
    <frame noresize="noresize" src="img/1.html"></frame>
    <frameset cols="50%, *">
        <frame noresize="noresize" src="img/2.html"></frame>
    	<frame noresize="noresize" src="img/3.html"></frame>
    </frameset>
</frameset> 
```

### 其他标签

```html
<!--网页关键字-->
<meta name="keywords" content="keyword1, keyword2, keyword3">
<!--网页描述-->
<meta name="description" content="this is my page">
<!--网页编码-->
<meta http-equiv="content-type" content="text/html;charset=UTF-8">
<!--页面跳转,2秒后自动跳转到百度-->
<meta http-equiv="refresh" content="2;URL=https://www.baidu.com">
<!--网页编码-->
<meta charset="utf-8">
<!--引入外部css-->
<link rel="stylesheet" type="text/css" href="./styles.css">
<!--引入外部js-->
<script type="text/javascript" src="./js1.js"></script>
```

## 四、CSS

### CSS使用方式

外联式

```html
<!--链接式-->
<link rel="stylesheet" type="text/css" href="div.css"></link>
<!--导入式-->
<style type="text/css">
	@import url("div.css")
</style>
```

备注：link和@import区别

1. link所有浏览器都支持，@import有些低版本的ie不支持
2. @import是等待html加载完成才加载，link是解析到这个语句就加载
3. @import不支持js动态修改

### 选择器

#### 1、标签选择器

直接使用需要增加样式的标签的名字

```html
<style type="text/css">
    h1 {
        color : red;
    }
</style>
<body>
    <h1>我是余文乐</h1>
</body>
```

#### 2、id选择器

`#`号加上需要增加样式的标签的id值

```html
<style type="text/css">
    #wyz {
        color : pink;
    }
</style>
<body>
    <span id="wyz">这是吴彦祖</span>
</body>
```

类选择器

`.`加上需要增加样式的标签的class值

```html
<style type="text/css">
    .shuai {
        color : pink;
    }
</style>
<body>
    <ul>
        <li>刘德华</li>
        <li>张学友</li> 
        <li>郭富城</li>
        <li>黎明</li>
    </ul>
</body>
```



id优先级最高，class其次，标签选择器最低

#### 3、属性选择器

**语法规则**

标签名[属性="值"] {

​	...

}	

```sql
 <style type="text/css">
        input[type="text"] {
            background-color : red;
        }

        /*a标签href属性以http开头*/
        a[href^="http"] {
            color: pink;
        }
        /*a标签href属性以com结尾*/
        a[href$="com"] {
            font-family: "华文彩云";
        }
        /*a标签href包含w*/
        a[href*="w"] {
            font-size : 30px;
        }
    </style>
<body>
    name: <input type="text" name="name" value="zhangsan"><br>
    pwd : <input type="password" name="password" value="123">

    <a href="http://www.baidu.com">百度</a>
    <a href="www.qq.com">腾讯</a>
</body>
```

#### 4、伪元素选择器

多用于a标签

```html
<style type="text/css">
    <!--静止-->
    a:link {
        color:red;
    }
    <!--悬浮-->
    a:hover {
        color:green;
    }
    <!--点击-->
    a:active {
        color:yellow;
    }
    <!--完成-->
    a:visited {
        color:blue;
    }
</style>
```

对于p标签，hover和active生效

#### 5、层次选择器

包含选择器

```css
div span {
    
}
选择的是div中的span标签
```

子代选择器

```css
div>span {
    
}
选择的是div中有一个直接套着的的span标签
```

相邻选择器

```css
div+p {
    
}
表示所有与div同级别的相邻p标签
```

通用兄弟选择器

```css
div~p {
    
}
表示div同级别的所有p标签
```



## 五、Servlet和Jsp

### 1、tomcat

tomcat的项目目录结构

--图片，html，css，js等静态资源

--WEB-INF文件夹

​	--classes：存放class文件

​	--lib：存放项目使用的jar包

​	--web.xml：配置文件

### 2、web.xml的Servlet配置

```xml
<servlet>
	<servlet-name>myServlet</servlet-name>
    <servlet-class>com.ecust.www.MyServlet</servlet-class>
</servlet>
<servlet-mapping>
	<servlet-name>myServlet</servlet-name>
    <url-pattern>/test</url-pattern>
</servlet-mapping>
```

```
容器在进行url-pattern配置的时候是遵循一定的匹配原则的
精确匹配	/具体的名称
后缀匹配	*.xxx
通配符匹配	/*			所有资源
通配符匹配	/			所有资源，但不包括.jsp

如果两个都可以符合请求的路径，首先符合精确匹配
```

load-on-startup：在容器创建时就运行

##### 默认页面

```xml
<welcome-file-list>
	<welcome-file>index.jsp</welcome-file>
</welcome-file-list>
```

##### 错误页面

```xml
<error-page>
    <!--如果遇到指定的状态码，显示指定的页面-->
	<error-code>404</error-code>
    <location>/error/404.html</location>
</error-page>
```



### 3、注解配置Servlet

注解类WebServlet

@WebServlet

value：配置url路径

urlPatterns：配置url路径，与value作业相同，不能同时使用

loadOnStartUp

### 4、Servlet的处理

1. 第一次访问Servlet时，服务器会创建对象，并调用init方法，最后执行service方法
2. 以后的访问只执行service方法
3. 服务器停止时，会执行destroy方法

#### 1、编写Servlet的三种方式

1. 实现Servlet接口

2. 继承GenericServlet：抽象类，实现了Servlet接口，并覆盖了除了service以外的所有方法。与协议无关

3. 继承HttpServlet：基于Http协议，对于专门的请求需要专门的方法实现。如Get请求会调用doGet，post请求会调用doPost

#### 2、请求的参数以及请求响应乱码

请求的参数

```java
request.getParameter("username");
```

请求乱码

```
注意，对于Get请求来说
在Tomcat7及以下的版本，对于请求的数据客户端以UTF-8的编码传递到服务器端，服务器以ISO8859-1的格式进行解码，会产生乱码
Tomcat8以后不会出现，服务器会对url编码形式进行自动转换

对于Post请求
仍然会出现乱码
```

解决请求的乱码

```java
request.setCharacterEncoding("utf-8");
```

响应的乱码

```
浏览器对于没有指定编码格式的数据默认使用GB2312形式进行编码
```

解决响应的乱码

```java
response.setContentType("text/html;charset=UTF-8");
response.setCharacterEncoding("utf-8");
```

### 5、页面跳转

#### 1、重定向

实现原理

```
客户端发送http请求
web服务器接收后发送302状态码并响应新的location给浏览器
浏览器自动发送一个新的http请求，url是新的location地址
服务器根据此请求寻找资源并发送给浏览器
```

特点

```
1、重定向是客户端行为，浏览器至少做了两次的访问请求
2、重定向后浏览器地址改变，并且两次跳转之间的传输信息会丢失
3、重定向可以指向任何的资源，包括当前应用程序的其他资源，同一个站点上的其他应用程序的资源，其他站点的资源
注意：使用response.sendRedirect("/mytest/index.html");这里的相对URL以"/"开头，它是相对于整个WEB站点的目录，在tomcat中即是"localhost:8080/"
```

#### 2、请求转发

实现原理

```
客户浏览器发送http请求
web服务器接收请求
调用内部的方法在容器内部完成请求转发和处理
服务器响应数据给浏览器
```

特点

```
1、转发是服务器行为
2、浏览器只进行了一次请求，地址url不变
3、转发两次跳转之间传输的信息不会丢失（重定向因为两次连接，http是无状态），可以通过request传递数据
4、请求转发只能转发给同一个WEB应用中的组件
request.getRequestDispactcher("/login.html").forward(request, response);
注意：这里的相对URL以“/”开头，相对于当前WEB应用程序的根目录，在tomcat中即是"localhost:8080/项目/"
```

### 6、生命周期

阶段一：实例化（构造方法）（使用或者容器加载）

阶段二：初始化（init方法）（紧随实例化）

阶段三：就绪/服务（service方法）（访问该Servlet）

阶段四：销毁（destroy方法）（服务器关闭）

### 7、线程安全问题

由于Servlet是单例的，所以每一个客户端访问会共享成员变量，会导致线程不安全

尽可能使用局部变量

### 8、Servlet初始化参数

#### 1、web.xml形式

```xml
<servlet>
	<servlet-name>login</servlet-name>
    <servlet-class>com.example.controller.LoginServlet</servlet-class>
    <init-param>
    	<param-name>username</param-name>
        <aram-value>张三</aram-value>
    </init-param>
</servlet>
1、init-param元素用来定义Servlet启动的参数，可以定义多个
2、param-name表示参数名称
3、param-value表示参数值
```

#### 2、注解方式

```java
@WebServlet(value="/login", initParams={@WebInitParam(name="username", value="aqiang"), @WebInitParam(name="password", value="123456")})
public class LoginServlet extends HttpServlet {
    
}
```

#### 3、获取

```java
// Servlet
this.getServletConfig().getInitParamter(name);
```



### 9、状态管理

```
WEB应用中的会话是指一个客户端浏览器与WEB服务器之间连续发生的一系列请求与响应过程。
WEB应用的会话状态是指WEB服务器与浏览器在会话过程中产生的状态信息，借助会话状态，WEB服务器能够把属于同一会话中的一系列的请求和响应过程关联起来。
```

常见的两种状态管理的模式

```
客户端状态管理技术：将状态保存在客户端。代表性的是Cookie技术
```

```
服务器状态管理技术：将状态保存在服务器端。代表性的是session技术（服务器传递sessionID时需要使用Cookie的方式）
```

#### 1、Cookie

```
Cookie是在浏览器访问WEB服务器的某个资源时，由WEB服务器在Http响应消息头中附带传送给浏览器的一小段数据，WEB服务器传送给各个客户端浏览器的数据是可以是各不相同的。
一旦WEB浏览器保存了某个Cookie，那么在以后每次访问该WEB服务器时，都应在Http请求头中将这个Cookie回传给WEB服务器。
WEB服务器通过在Http响应消息中增加Set-Cookie响应头字段将Cookie信息发送给浏览器，浏览器则通过在Http请求消息中增加Cookie请求头字段将Cookie回传给WEB服务器

一个Cookie只能标识一种信息，至少含有一个标识该信息的名称（NAME）和设置值（VALUE）
一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie
```

创建Cookie

```java
Cookie cookie = new Cookie("name", "zhangsan");
cookie.setAge(-1);  // 设置Cookie的有效期,>0表示有效期(在当前的时间上进行叠加)，单位秒；=0失效；<0存储在内存 默认-1
response.addCookie(cookie);
```

cookie的默认生命周期到浏览器窗口关闭为止

cookie的共享范围：同一个项目下

如果想要让cookie可以在同一个服务器下所有项目共享，可以这样设置

```java
cookie.setPath("/");
```

获取Cookie

```java
Cookie[] cookies = request.getCookies();
```

#### 2、Session

```
Session用于跟踪客户端的状态。Session指的是在一段时间内，单个客户与web服务器的一连串相关的交互过程。在一个Session中，客户可能会多次请求访问同一个网页，也有可能请求访问各种不同的服务器资源。
```

##### Session工作原理

```java
session被用于表示一个持续的连接状态，在网站访问中一般指代客户端浏览器的进程从开启到结束的过程。session其实就是网站分析的访问（visits）度量，表示一个访问的过程。
session的常见实现形式是cookie（session cookie），即未设置过期时间的cookie，这个cookie的默认生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。实现机制是当用户发起一个请求的时候，服务器会检查该请求是否包含sessionid，如果未包含，则Tomcat会创造一个名为JSESSIONID的输出cookie返回给浏览器（只放入内存中，并不存在硬盘上），并将其以HashTable的形式写到服务器的内存里面；当已经包含了sessionid时，服务器会检查找到与该session相匹配的信息，如果存在则直接使用该sessionid，若不存在，则重新生成新的session。这里需要注意的是session始终是由服务端创建的，并非是浏览器自己生成的。
```

获取session

```java
// 获取session对象；先判断对象是否存在，如果不存在就创建
HttpSession session = request.getSession();
// 判断当前request中sessionid是否仍然valid
boolean validate = req.isRequestedSessionIdValid();
```

session的方法

```java
// 获取sessionid
int id = session.getId();
// 获取最后一次访问时间，单位毫秒
long lastAccessedTime = session.getLastAccessedTime();
// 获取最大的空闲时间，单位秒，默认是30分钟
int maxInactiveTime = session.getMaxInactiveInternal();
// 获取session的创建时间，单位毫秒
long createTime = session.getCreationTime();
```

如何使用session绑定对象

```
session.setAttribute(属性名，object);
```

如何使用session获取对象

```java
// 获取存储在session中的对象，如果没有匹配的属性名，返回null
Object session.getAttribute(属性名);
```

如何删除session

```java
session.invalidate();
```

##### 浏览器禁用Cookie的后果

```
如果浏览器禁用Cookie，则sessionID不会被浏览器保存，此时，服务器可以使用如URL重写的方式来发送sessionID
```

```
使用Session区分每个用户的方式：
1、使用Cookie
2、作为隐藏域嵌入HTML表单中，附加在主体的url上，通常作为指向其他应用程序页面的链接，即URL重写
```

URL重写

```
浏览器在访问服务器上的某个地址时，不在使用原来的地址，而是使用经过改写的地址
即在原来的地址上加了sessionID
```

如何实现URL重写

```
如果是链接地址和表单提交，使用
response.encodeURL(String url)生成重写后的地址
如果是重定向，使用
response.encodeRedirectedURL(String url)生成重写的url，供response.sendRedirect(url)使用

上述两个方法都会先判断浏览器是否禁用cookie，如果没有禁用，则url不改变，如果禁用了，会在后面追加jsessionid的值
```

##### Session超时

```
HttpSession的最后一次访问时间和当前时间的差距大于指定的最大空闲时间，这时服务器就会销毁Session对象
默认的空闲时间是30分钟
```

修改Session的最大空闲时间

```
// 1.使用HttpSession的session.setMaxInactiveInternam（20 * 60），单位秒

// 2.在web.xml中配置，单位分钟
	<session-config>
		<session-timeout>20</session-timeout>
	</session-config>
	
同时配置的情况下，第一种的优先级更高
```

session失效的几种情况

```
1、超过了设置的超时时间
2、主动调用了invalidate方法
3、服务器主动或异常关闭
```

##### 验证码

validateCode.jar

```java
// codeCount是显示的验证码的位数
// lineCount是干扰线的条数
ValidateCode codeData = new ValidateCode(int width, int height, int codeCount, int lineCount);

// 获取验证码的值
String code = codeData.getCode();

// 写出验证码
codeData.write(resp.getOutputStream());
```

带有验证码的登录案例

ValidateCodeServlet

```java
package com.example.loginInWithSession;

import cn.dsna.util.images.ValidateCode;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

@WebServlet("/validateCode")
public class ValidateCodeServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doPost(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ValidateCode code = new ValidateCode(100, 40, 4, 5);
        HttpSession session = req.getSession();
        session.setAttribute("code", code);
        code.write(resp.getOutputStream());
    }
}
```

loginSession.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

    <form action="/servletuse/loginSession" method="post">
        用户名:<input type="text" name="username"/><br>
        密码:<input type="password" name="password"/><br>
        验证码:<input type="text" name="validate"/><img id="code" src="/servletuse/validateCode" onclick="changePic()"/><br>
        <input type="submit" value="登录"/>
    </form>

    <script>
        function changePic() {
            var img = document.getElementById("code");
            // 如果每次请求的网址一样，浏览器不会刷新
            img.src = "/servletuse/validateCode?time=" + new Date().getTime();
        }
    </script>
</body>
</html>
```

loginSessionServlet

```java
package com.example.loginInWithSession;

import cn.dsna.util.images.ValidateCode;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;


@WebServlet("/loginSession")
public class LoginServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doPost(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        HttpSession session = req.getSession();
        String user = (String) session.getAttribute("username");
        if (user != null) {
            resp.sendRedirect("/servletuse/success.html");
            return;
        }


        String username = req.getParameter("username");
        String password = req.getParameter("password");
        String validate = req.getParameter("validate");
        ValidateCode code = (ValidateCode) session.getAttribute("code");
        System.out.println(username + ": " + password + "; " + validate + "==" + code.getCode());

        if (code.getCode().equalsIgnoreCase(validate) && username.equals("zhangsan") && password.equals("123456")) {
            session.setAttribute("username", username);
            resp.sendRedirect("/servletuse/success.html");
        } else {
            resp.sendRedirect("/servletuse/loginSession.html");
        }
    }
}
```

### 10、ServletContext

ServletContext是Servlet上下文，代表了当前整个应用程序 （jsp中的application）

```
当WEB服务器启动的时候，会为每一个WEB应用程序（webapps下的目录就是一个应用程序）创建一块共享的存储区域
ServletContext对于同一个WEB应用程序来说，所有的Servlet和JSP是共享的
ServletContext在WEB服务器启动时创建，服务器关闭时销毁
```

#### 10.1、获取ServletContext对象的方法

```
1、 GenericServlet提供了getServletContext()方法   推荐
2、 ServletConfig提供了getServletContext()方法
3、 HttpSession提供了getServletContext()方法
4、 HttpServletRequest提供了getServletContext()方法  推荐
```

#### 10.2、ServletContext的作用

```java
// 1.获取真实路径，即当前项目的发布路径(绝对路径)
request.getServletContext().getRealPath("/");

// 2.获取容器的附加信息
// 获取容器信息
request.getServletContext().getServletInfo();
// 获取上下文路径（项目路径，如/day10）
request.getServletContext().getContextPath();

// 3.获取数据
request.getServletContext().getAttribute("msg");

// 4.添加数据
request.getServletContext().setAttribute("msg", "共享信息");

// 5.删除数据
request.getServletContext().removeAttribute("msg");
```

#### 10.3、配置初始化参数

在web.xml配置ServletContext的参数

```xml
<context-param>
	<param-name>appname</param-name>
    <param-value>xxxxx</param-value>
</context-param>

<context-param>
	<param-name>appVersion</param-name>
    <param-value>2.0</param-value>
</context-param>

// 获取servlet上下文参数
String appname = this.getServletContext().getInitParamter("appname");
String appversion = this.getServletContetx().getInitParameter("appversion");
```

### 11、过滤器Filter

```
Filter也称之为过滤器，WEB开发人员通过Filter，对web服务器管理所有的web资源：例如JSP，Servlet，静态图片文件或静态html文件等进行拦截，从而实现一些特殊功能。
如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。

Servlet API中提供了一个Filter接口，开发WEB应用时，如果编写的Java类实现了这个接口，则把这个Java类称之为过滤器Filter。通过Filter技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应进行拦截。
```

#### 11.1 Filter的配置

web.xml

```xml
	<filter>
        <filter-name>wordFilter</filter-name>
        <filter-class>cn.zhanguozhi.servlet.filter.WordFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>wordFilter</filter-name>
<!--        <url-pattern>/filterWord</url-pattern>-->
        <!-- 过滤指定名称的Servlet，可以指定多个 但不可以和url-pattern同时出现在一个filter内 -->
        <servlet-name>wordServlet</servlet-name>
    </filter-mapping>

    <servlet>
        <servlet-name>wordServlet</servlet-name>
        <servlet-class>cn.zhanguozhi.servlet.filter.WordServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>wordServlet</servlet-name>
        <url-pattern>/filterWord</url-pattern>
    </servlet-mapping>
```

注解配置

```java
@WebFilter(filterName = "ApplicationFilter", value = "/*")
```

11.2 过滤器链

```
通常客户端对服务器请求之后，服务器调用Servlet之前会执行一组过滤器，这组过滤器就称为过滤器链
每个过滤器实现某个特定的功能，一个过滤器检测多个Servlet

对于使用xml配置方式来说，一组过滤器的执行顺序与<filter-mapping>的配置顺序有关，先配置先执行
对于使用注解配置方式来说，执行顺序与过滤器包名和类名的字典顺序有关
xml配置方式的优先级高于注解方式（但实际操作下来，注解优先调用）

当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法
在doFilter方法中，开发人员如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用下一个filter，如果没有，则调用目标资源
```

#### 11.2 Filter的初始参数

xml配置

```xml
	<filter>
        <filter-name>wordFilter</filter-name>
        <filter-class>cn.zhanguozhi.servlet.filter.WordFilter</filter-class>
        <init-param>
            <param-name>filterParam</param-name>
            <param-value>这是从FilterConfig获取的</param-value>
        </init-param>
    </filter>
```

获取需要调用FilterConfig的getInitParameter(String name)得到，并且这个对象是Filter中init方法的参数，所以获取初始参数需要在init方法中进行

注解配置

```java
@WebFilter(filterName = "ApplicationFilter", value = "/*",
        initParams = {@WebInitParam(name="applicationFilter", value="这是从注解配置中获取的")})
```

#### 11.3 Filter的应用

##### 1、设置编码

web.xml

```xml
<filter>
    <filter-name>characterEncodingFilter</filter-name>
    <filter-class>cn.zhanguozhi.filter.CharacterEncodingFilter</filter-class>
    <init-param>
      <param-name>charset</param-name>
      <param-value>UTF-8</param-value>
    </init-param>
  </filter>
  <filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
	<!--过滤所有的Servlet，包括jsp，没有*是不包括jsp-->
    <!--如果/*会使页面乱码，可以将所有servlet以.do结尾，只过滤servlet-->
    <url-pattern>/*.do</url-pattern>
  </filter-mapping>
```

CharacterEncodingFilter类

```java
package cn.zhanguozhi.filter;

import javax.servlet.*;
import java.io.IOException;

public class CharacterEncodingFilter implements Filter {

    // default charset
    private String charset = "UTF-8";

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        String charsetConfig = filterConfig.getInitParameter("charset");
        if (charsetConfig != null) {
            // 配置了charset的初始参数
            charset = charsetConfig;
        }
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        request.setCharacterEncoding(charset);
        response.setContentType("text/html;charset=" + charset);
        chain.doFilter(request, response);
    }

    @Override
    public void destroy() {

    }
}
```

##### 2、自动登录 + 权限验证

自动登录的逻辑是在第一次登录成功的时候将登录信息保存至session和cookie中

之后如果访问**登录页面**，会检查session和cookie，如果有，则自动登录，跳转到登录后的页面，如果没有则正常显示

登录时会判断查询到的user的权限，跳到不同的页面，大体功能都是查询所有，但是管理员可以修改或删除

LoginServlet类

```java
package cn.zhanguozhi.servlet;

import cn.dsna.util.images.ValidateCode;
import cn.zhanguozhi.entity.User;
import cn.zhanguozhi.service.UserService;
import cn.zhanguozhi.service.impl.UserServiceImpl;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.*;
import java.io.IOException;

@WebServlet(name = "loginServlet", value = "/login.do")
public class LoginServlet extends HttpServlet {

    private UserService userService = new UserServiceImpl();


    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        HttpSession session = req.getSession();
        String username = req.getParameter("username");
        String password = req.getParameter("password");
        String codeStr = req.getParameter("code");
        System.out.println(codeStr);
        // 是否需要cookie存储
        String needCookie = req.getParameter("needCookie");
//        System.out.println(needCookie);

        // 先判断验证码是否正确（实际这一步应该是在前端完成）
        ValidateCode code = (ValidateCode) session.getAttribute("code");
        if (!code.getCode().equalsIgnoreCase(codeStr)) {
            System.out.println("验证码错误");
            resp.sendRedirect("/servlet_pro/loginPage.html");
        }

        // 这个方式是从登录页面传递过来的信息
        // 不需要判断有没有session中存储的信息和cookie
        User user = userService.checkUser(username, password);
        if (user == null) {
            resp.getWriter().println("登录失败，3秒后跳转到登录页面");
            // 三秒后，跳转到错误页面
            resp.setHeader("refresh", "3;url='/servlet_pro/loginPage.html'");
        } else {
            session.setAttribute("username", user);

            if ("1".equals(needCookie)) {
                Cookie username1 = new Cookie("username", user.getUsername());
                Cookie password1 = new Cookie("password", user.getPassword());
                // 设置一周内登录有效
                username1.setMaxAge(60 * 60 * 24 * 7);
                password1.setMaxAge(60 * 60 * 24 * 7);
                resp.addCookie(username1);
                resp.addCookie(password1);

            }
            if (user.getAuthority() == 1)
                // 管理员
                resp.sendRedirect("/servlet_pro/adminAction.do");
            else
                // 用户
                resp.sendRedirect("/servlet_pro/getAllStudents.do");
        }

    }
}
```

LoginFilter类

```java
package cn.zhanguozhi.filter;

import cn.zhanguozhi.entity.User;
import cn.zhanguozhi.service.UserService;
import cn.zhanguozhi.service.impl.UserServiceImpl;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

@WebFilter("/loginPage.html")
public class LoginFilter implements Filter {

    private UserService userService = new UserServiceImpl();

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse resp = (HttpServletResponse) response;
        HttpSession session = req.getSession();
        Object username = session.getAttribute("username");
        System.out.println(username);
        if (username != null) {
            // session 有登录信息
            resp.sendRedirect("/servlet_pro/adminOperation.html");
            return;
        } else {
            // 检查cookie
            Cookie[] cookies = req.getCookies();
            String user = null;
            String password = null;
            User checkUser = null;
            if (cookies != null) {
                for (Cookie cookie : cookies) {
                    if ("username".equals(cookie.getName())) {
                        user = cookie.getValue();
                    } else if ("password".equals(cookie.getName())) {
                        password = cookie.getValue();
                    }
                }
            checkUser = userService.checkUser(user, password);
            }
            if (checkUser != null) {
                // 如果存在，就在session中设置属性
                session.setAttribute("username", checkUser);
                if (checkUser.getAuthority() == 1)
                    resp.sendRedirect("/servlet_pro/adminAction.do");
                else
                    resp.sendRedirect("/servlet_pro/getAllstudents.do");
                return;
            }
        }
        chain.doFilter(request, response);
    }

    @Override
    public void destroy() {

    }
}
```

管理员页面AdminStudentsServlet.java

```java
package cn.zhanguozhi.servlet;

import cn.zhanguozhi.entity.Student;
import cn.zhanguozhi.service.UserService;
import cn.zhanguozhi.service.impl.UserServiceImpl;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;

@WebServlet("/adminAction.do")
public class AdminStudentsServlet extends HttpServlet {

    private UserService userService = new UserServiceImpl();

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doPost(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        List<Student> students = userService.getAllStudents();
        PrintWriter writer = resp.getWriter();
        writer.println("<html>");
        writer.println("<head>");
        writer.println("<meta charset='utf-8'>");
        writer.println("</head>");
        writer.println("<body>");

        writer.println("<table border='1'>");
        writer.println("<tr>");
        writer.println("<th>学生编号</th>");
        writer.println("<th>学生姓名</th>");
        writer.println("<th>学生年龄</th>");
        writer.println("<th>操作</th>");
        writer.println("</tr>");
        for (Student stu : students) {
            writer.println("<tr>");
            writer.println("<td>" + stu.getId() + "</td>");
            writer.println("<td>" + stu.getName() + "</td>");
            writer.println("<td>" + stu.getAge() + "</td>");
            writer.println("<td>" + "<a href='#'>修改</a>&nbsp;&nbsp;<a href='/servlet_pro/deleteStu.do?id=" + stu.getId() + "'>删除</a>" + "</td>");
            writer.println("</tr>");
        }
        writer.println("</table>");

        writer.println("</body>");
        writer.println("</html>");
    }
}
```

用户页面GetAllStudentsServlet.java

```java
package cn.zhanguozhi.servlet;

import cn.zhanguozhi.entity.Student;
import cn.zhanguozhi.service.UserService;
import cn.zhanguozhi.service.impl.UserServiceImpl;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;

@WebServlet("/getAllStudents.do")
public class GetAllStudentsServlet extends HttpServlet {

    private UserService userService = new UserServiceImpl();

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doPost(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        List<Student> students = userService.getAllStudents();
        PrintWriter writer = resp.getWriter();
        writer.println("<html>");
        writer.println("<head>");
        writer.println("<meta charset='utf-8'>");
        writer.println("</head>");
        writer.println("<body>");

        writer.println("<table border='1'>");
        writer.println("<tr>");
        writer.println("<th>学生编号</th>");
        writer.println("<th>学生姓名</th>");
        writer.println("<th>学生年龄</th>");
        writer.println("</tr>");
        for (Student stu : students) {
            writer.println("<tr>");
            writer.println("<td>" + stu.getId() + "</td>");
            writer.println("<td>" + stu.getName() + "</td>");
            writer.println("<td>" + stu.getAge() + "</td>");
            writer.println("</tr>");
        }
        writer.println("</table>");

        writer.println("</body>");
        writer.println("</html>");
    }
}
```

管理员页面上的删除操作DeleteStudentServlet.java

```java
package cn.zhanguozhi.servlet;

import cn.zhanguozhi.service.UserService;
import cn.zhanguozhi.service.impl.UserServiceImpl;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/deleteStu.do")
public class DeleteStudentServlet extends HttpServlet {

    private UserService userService = new UserServiceImpl();

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doPost(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String id = req.getParameter("id");
        boolean res = userService.deleteStudent(Integer.parseInt(id));
        if (res) {
            System.out.println("删除成功");
        } else {
            System.out.println("删除失败或不存在该id");
        }

        // 删除操作完成，返回查询所有
        resp.sendRedirect("adminAction.do");
    }
}
```



##### 3、过滤脏词

```
对于脏词进行过滤
在过滤器中要修改传过来的脏词数据
因为request没有设置数据的方法，所以需要重写getParameter()方法
servlet api包装类实现了HttpServletRequestWrapper包装类实现了HttpServletRequest接口，专门给程序人员用来实例化HttpServletRequest接口进行适配
在该类的getParameter方法中，调用super的getParameter方法获取到原始数据，进行判断，如果是脏词，返回过滤后的数据
```



WordFilter.java类

```java
package cn.zhanguozhi.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@WebFilter("/filterWord.do")
public class WordFilter implements Filter {


    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) request;

        // 修改request对象中getParameter方法
        chain.doFilter(new DirtyWordRequest(req), response);

    }

    @Override
    public void destroy() {

    }

    private static class DirtyWordRequest extends HttpServletRequestWrapper {

        private static List<String> words = new ArrayList<>();

        /**
         * Constructs a request object wrapping the given request.
         *
         * @param request
         * @throws IllegalArgumentException if the request is null
         */
        public DirtyWordRequest(HttpServletRequest request) {
            super(request);
            words.add("王八蛋");
            words.add("sb");
            words.add("SB");
            words.add("cnm");
        }

        @Override
        public String getParameter(String name) {
            // 调用原本getParameter方法获取数据
            String word = super.getParameter(name);
            System.out.println("原始数据：" + word);
            for (String dirtyWord : words) {
                if (dirtyWord.equals(word)) {
                    return "世界真美好啊";
                }
            }
            return word;
        }
    }
}
```



### 12、动态网页开发JSP

```
Java Server Pages

Servlet: 1.接收浏览器发送的数据  2.负责调用业务层  3.转发重定向
JSP:主要用于显示页面
```

#### 12.1 JSP构成

JSP页面中包括指令、Java语句、变量、方法或表达式、静态内容（html、css、JavaScript）

脚本元素（Scripting Elements）：声明脚本段、表达式

注释指令（Comment Elements）：html注释、Java注释、JSP注释

指令元素（Directive Elements）：page、include、taglib等

动作元素（Action Elements）：jsp:include、jsp:forward、jsp:useBean等

##### 1、JSP指令

告诉JSP引擎如何解析jsp文件中的内容

语法：	<%@ 指令名称  属性名称1=“属性值1” 属性名称2="属性值2"  ... %>

* page指令

```
import属性：和Java代码一样
	<%@ page import="java.util.Date" %>
session属性：是否会自动创建session对象，默认值为true
buffer属性：JSP中有javax.servlet.jsp.JspWriter输出字符流。设置输出数据的缓存大小，默认是8kb
errorPage属性：如果页面中有错误，跳转到指定的资源
	<%@ page errorPage="/uri"  %>
	如果写“/”表示当前应用目录下，如果不写表示该页面的相对路径
isErrorPage属性：是否创建throwable对象，默认是false
contentType属性：等同于response.setContentType("text/html;charset=utf-8")，服务器发送客户端的内容编码
pageEncoding属性：JSP文件本身的编码
isELIgnored属性：是否支持EL表达式，默认是false，支持表达式（idea默认是true）
```

* include指令

```
include指令
	静态包含：把其他资源包含到当前页面中
		<%@ include file="header.jsp" %>
	动态包含：
		<jsp:include page="header.jsp"></jsp:include>
	两者的区别：
		静态包含：在编译时就把两个文件进行合并，运行时效率高
		动态包含：不会合并文件，当执行到include时，才包含另一个文件
```

* taglib指令

```
作用：在JSP页面中导入JSTL标签库。
<%@ taglib uri="http://java.sum.com/jsp/jstl/core" prefix="c" &>
```

##### 2、网页注释

格式：`<%-- 注释 -->`  安全，省流量  不会参与编译

而相较之下，网页注释`<!-- 注释 -->`，不安全，消耗流量

##### 3、脚本元素

* 脚本

  语法：<% Java代码 >

  在脚本里定义的变量是局部变量

* 脚本表达式

  <%=2+3 %>  等价于out.print(2+3); 但是是显示在网页上;（注意，不能使用分号结束表达式）

* 声明

  <%!  定义方法或全局变量  %>

##### 4、动作标签

* jsp:include动态包含

```
<jsp:include page="index.jsp"></jsp:include>
当前页面包含index.jsp
```

* jsp:forward请求转发

```
<jsp:forward>动作是在服务端完成的，浏览器地址栏内容不会发生改变(原理与Servlet请求转发一致)
可以通过<jsp:param>元素指定参数列表

<jsp:forward page="a.jsp">
	<jsp:param name="username" value="aqiang"/>
	<jsp:param name="password" value="123456"/>
</jsp:forward>
```

* JavaBean指令

```xml
<!--在_jspService方法内创建一个对象User，其引用为user-->
<jsp:useBean id="user" class="com.baidu.entity.User"></jsp:useBean>

<!--为引用为user的变量的username属性赋值"liudehua"-->
<jsp:setProperty name="user" property="username" value="liudehua"></jsp:setProperty>
<jsp:setProperty name="user" property="password" value="123456"></jsp:setProperty>

<!--获取引用为user的变量的username属性的值-->
<jsp:getProperty name="user" property="username"></jsp:getProperty>

<!--与表单进行精确匹配  要求：发送请求过来的页面中的表单数据的name值要与实体类的属性名完全一致-->
<jsp:useBean id="user" class="com.baidu.entity.User"></jsp:useBean>
	<!--不设置value时，会从请求数据中取user对象同名的parameter赋值-->
	<jsp:setProperty property="*" name="user"/>
用户名：<jsp:getProperty name="user" property="username"/>
密码：<jsp:getProperty name="user" property="password"/>
```

有一个用途：为了避免在Servlet中获取大量的请求参数之后封装对象，可以使用缓冲页面封装对象，然后通过request的setArrtibute将对象赋值进去，再请求转发到对应的Servlet

#### 12.2 内置对象

Servlet的内置对象：request、response、session、servletContext、config、printWriter

JSP的内置对象：

| 对象名          | 类型                                   | 说明                     |
| --------------- | -------------------------------------- | ------------------------ |
| request         | javax.servlet.http.HttpServletRequest  |                          |
| response        | javax.servlet.http.HttpServletResponse |                          |
| session         | javax.servlet.http.HttpSession         | 由session="true"开关     |
| application     | javax.servlet.ServletContext           |                          |
| config          | javax.servlet.ServletConfig            |                          |
| exception       | java.lang.Throwable                    | 由isErrorPage="true"开关 |
| **out**         | javax.servlet.jsp.JspWriter            |                          |
| **pageContext** | javax.servlet.jsp.PageContext          | 当前jsp页面上下文        |
| page            | java.lang.Object  当前对象this         | 当前对象Servlet实例      |

四个作用域对象pageContext，request，session，application作用域从小到大

```
request的使用场景：根据学号查询学生，根据新闻id查询新闻
session的使用场景：用户登录信息
application的使用场景：整个程序的配置信息
```



jsp的out和response.getWriter()方法区别

```
1、out是JspWriter类型，getWriter()是PrintWriter类型
2、out输出到缓冲区，没有写到response中，getWriter()直接写到response中，所以getWriter的效率更高
3、out一般用在jsp中，getWriter一般用在Servlet中
```

##### pageContext对象

作用：  1、作为容器使用，作用域为当前页面

​			  2、代表页面上下文，获取其他八个内置对象

```
和其他的域对象一样，pageContext.setAttribute("name", Object)可以直接设置属性和值，但是范围只能在当前页面生效

如果想要向其他三个域对象存储属性和值，pageContext.setAttribute("name", Object, int scope)  
第三个参数就是存储的范围
同理还有获取值pageContext.getAttribute("name", int scope)
还有删除值pageContext.removeAttribute("name", int scope)
PageContext.REQUEST_SCOPE  request域
PageContexe.SESSION_SCOPE  session域
PageContext.APPLICATION_SCOPE   application域

pageContext.findAttribute(String name):在域对象中按照范围从小到大找name属性对应的value，如果存在就返回

获取其他内置对象（没必要，可以直接写）
getSession(),getRequest(),getResponse(),...
```

#### 12.3 EL表达式

EL表达式：Expression Language表达式语言

目的：简化jsp中java代码，代替脚本表达式

* ${name}
  * 等价于pageContext.findAttribute("name");
* ${user.username}
  * 等价于user.getUsername();  //但是user对象需要已经被存储在作用域中

如果想拿指定作用域的属性，需要指明作用域

pageScope, requestScope, sessionScope, ApplicationScope

```
如果想要获取List和Map中的值
<%
	List<String> list = new ArrayList<>();
	list.add("nihao");
	list.add("hello");
	request.setAttribute("list", list);
	
	Map<String, String> map = new HashMap<>();
	map.put("CN", "中国");
	map.put("UK", "英国");
	map.put("US", "美国");
	request.setAttribute("map", map);
%>
// 拿list的数据
${list[0]}
${list.get(O)}
// 拿map的数据
${map["CN"]}
${map.get("CN")}
${map.CN}

因为set存储的值是无序无下标的，取值需要通过for循环遍历，而EL表达式只能每次取一个值，因此不能直接取
```

* EL表达式可以执行运算
  * 算术运算，逻辑运算，关系运算
* empty运算符  ${empty name}
  * 只要name所代表的值内容为空即返回true，如null、""
* 隐式对象11个
  * 包括四个作用域PageScope，...
  * param表示request.getParameter("username);   ${param.username}
  * paramvalues表示request.getParameterValues("hobby");       ${paramValues.hobby}
  * header表示request.getHeader("accept");     ${header.accept}
  * headerValues表示request.getHeaderValues("accept-encoding");   ${headerValues["accept-encoding]}
  * cookie表示request.getCookie();    ${cookie.JSESSIONID}
  * initParam表示初始化参数ServletContext中设置的值（web.xml的context-param)
* 项目根路径
  * ${pageContext.request.contextPath}

#### 12.4 JSTL

全称Java Server Pages Standard Tag Library, JSP标准标签库，代替jsp页面的脚本，实现逻辑控制

需要导入jstl的jar包

```
// 在页面中使用jstl需要添加taglib指令
<% @taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c">
```

* 常用标签

```java
// 声明变量  var是变量名  value是变量值 
// target是操作的对象 property是操作的对象的属性
// 默认存储在pageContext中  如果想要指定具体的作用域  可以使用scope
<c:set var="k" value="${1+1}"></c:set>

// 打印变量a的值
// 如果a不存在，显示default属性的值
<c:out value="${a}" default="空值"/>

// 删除变量名为k的变量
<c:remove var="k"/>
```

选择结构

```html
<c:if test="${5>2}">
	// 如果test的值为true，执行标签内的语句
</c:if>

<c:choose>
	<c:when test="${score>=90}">优秀</c:when>
    <c:when test="score>=80">良好</c:when>
    <c:when test="score>=70">中等</c:when>
    <c:when test="score>=60">及格</c:when>
    <c:otherwise>不及格</c:otherwise>
</c:choose>
```

循环结构

```html
<!-- 遍历for：输出1到10的值 -->
// var:变量遍历的变量
// begin:开始，可以使用EL表达式
// end:结束，可以使用EL表达式
// step:间隔的长度
<c:foreach var="i" begin="1" end="10" step="2">
${i}
</c:foreach>


// items:集合，数组类型的变量名
// var:在集合或者数组中每一次遍历得到的值或对象
// varStatus:遍历出来每一项内容的状态
// isFirst()   first
// isLast()    last
// getCount()  count  用来计数
// getIndex()  index
<c:forEach items="users" var="user" varStatus="vs">
    ${vs.isFirst()}
</c:forEach>
```

#### 12.5 MVC

三层架构（Presentation界面层，BL业务逻辑层，DA数据访问层）

* 三层架构是根据业务进行拆分的，MVC基于页面来分

* 三层架构是体系结构模式，MVC是设计模式

```
Model——View——Controller
控制器Controller：控制请求的处理逻辑，对请求进行处理，负责请求转发和重定向
视图View：视图是用户看到并与之交互的界面，比如html（静态），jsp（动态）
模型Model：模型代表着一种企业规范，就是业务流程/状态的处理以及业务规则的规定。业务流程的处理过程对其他层来说是不透明的，模型接受请求，并返回最终的处理结果。

业务模型的设计是MVC的核心
```

