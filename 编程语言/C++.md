# C++

## 基础语法

### 1 常量

* #define 宏常量：`#define 常量名 常量值`
  * 通常在文件上方定义
* const修饰的变量：`const 数据类型 变量 = 值`



### 2 sizeof关键字

作用：利用sizeof关键字可以统计数据类型所占内存大小

语法：`sizeof(数据类型 或者 变量)`



### 3 指针

在x86下，指针变量占4个字节

在x64下，占8个字节



#### 3.1 const与指针

const修饰指针

* 常量指针
  * `const int *p = &a;`
  * 常量指针
  * 特点：指针的指向可以修改，但是指针指向的值不可以改
  * 即不可以通过`*p`去修改值
* 指针常量
  * `int * const p = &a;`
  * 特点：指针的指向不可以改，但是指针指向的值可以修改
* const既修饰指针又修饰常量
  * `const int* const p = &a；`
  * 特点：指向和指向的值都不可以修改



## 核心编程

### 1 内存区域

C++程序执行时，将内存大方向划分为4个区域

* 代码区：存放函数体的二进制代码，由OS进行管理
* 全局区：存放全局变量和静态变量以及常量
* 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
* 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

**内存四区意义**：

不同区域存放的数据，赋予不同的生命周期，给程序员更大的灵活编程

#### 1.1 程序运行前

在程序运行前，生成了exe程序，未执行程序前分为两个区域

* 代码区：
  * 存放CPU执行的机器指令
  * 代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
  * 代码区是**只读**的，使其只读的原因是防止程序意外地修改其指令
* 全局区：
  * 全局变量和静态变量存放在此
  * 全局区还包含了常量区，字符串常量和其他全局常量也存放在这里
  * 该区域的数据在程序结束后由操作系统释放

#### 1.2 程序运行后

* 栈区
* 堆区
  * 在C++中主要利用new在堆区开辟内存

#### 1.3 new关键字

```c++
// 在堆区开辟内存
int *p = new int(10);

// 释放内存
delete p;

// 之后再访问p会报错

// 开辟数组
int *arr = new int[10];
// 释放数组
delete[] arr;
```



### 2 引用

#### 2.1 基本使用

作用：给变量起别名

语法：`数据类型 &别名 = 变量名`

注意：

* 引用必须要初始化
* 引用一旦初始化，就不可以更改



#### 2.2 引用做函数参数

作用：函数传参时，可以利用引用的技术让形参修饰实参

优点：可以简化指针修改实参

```c++
void swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}
// 这段代码会交换实参的值
```

通过引用参数产生的效果与按地址传递是一样的



#### 2.3 引用做函数返回值

```c++
int& test()
{
    static int a = 10;
    return a;
}
```



如果函数的返回值是引用，这个函数调用可以作为左值



#### 2.4 引用的本质

引用的本质就是一个指针常量，指向的地址不可改变，但指向的地址所表示的值可以改变

而且编译器遇到引用会变成指针的形式

```c++
int a = 10;
int &b = a;
b = 10; // -> *b = 10;
```



#### 2.5 常量引用

使用场景：用来修饰形参，防止误操作

```c++
int a = 10;
const int &ref = a; // 此时是一个常量指针，也是一个指针常量
```



### 3 函数高级

#### 3.1 默认参数

1. 如果某个参数是默认参数，则此参数及以后的参数都必须是默认参数
2. 函数声明和实现，最多只能有一个里面有默认参数（避免二义性）

```c++
int test(int a, int b = 10, int c = 20){}
```



#### 3.2 占位参数

定义时只列出数据类型，并没有形参名字

调用时必须填补该位置

注：

* 占位参数可以有默认值

```c++
void test(int a, int){}  // 第二个参数是占位参数

test(1, 2);
```



#### 3.3 函数重载

方法参数个数不同、或顺序不同、或类型不同

注：

* 引用可以作为重载的条件

  * 此时是类型不同

  * ```c++
    void func(int &a){}
    void func(const int &b){}
    ```



### 4 面向对象

#### 4.1 封装

语法：`class 类名{ 访问权限: 属性/行为};`



##### 4.1.1 访问权限

* public
* protected
* private



##### 4.1.2 struct和class区别

唯一区别在于默认访问权限不同

* struct默认是public
* class默认是private



### 4.2 对象的初始化和清理

#### 4.2.1 构造函数和析构函数

如果不提供构造函数和析构函数，编译器会默认提供空实现的函数

构造函数语法：`类名(){}`

* 调用
  * 无参：`Person p;`
    * 不要加括号（编译器认为这是一个声明）
  * 有参：`Person p(10);`
  * 匿名对象：`Person(10);`
    * 当前行执行结束后，系统会立即回收匿名对象
  * 显示创建：`Person p = Person(10);`

析构函数语法：`~类名(){}`

* 析构函数不可以有参数，因此不可以发送重载
* 程序在对象销毁前会自动调用析构函数，无须手动调用，且只调用一次



#### 4.2.2 拷贝构造函数

不写，编译器会提供一个默认的，且对属性做了值拷贝

语法：

```c++
class Person
{
    public :
    	int age;
    Person(const Person p)
    {
        this.age = p.age;
    }
}
```



#### 4.2.3 初始化列表

语法：`构造函数(int a, string b):属性1(a),属性2(b),...`



#### 4.2.4 静态成员

static关键字修饰

* 静态成员变量
  * 在编译阶段共享内存
  * 所有对象共享一份数据
  * 类内声明，类外初始化
  * 对象和类名都可以访问`类名::静态变量`



#### 4.2.5 存储方式

C++编译器会给每一个空对象分配一个内存空间，是为了区分空对象占内存的位置



this是指向本类对象的指针，是一个指针常量，即指向不能修改

在成员函数后添加const，表示该函数是一个常函数，即this指向的值不能修改

如果仍要修改可以在声明属性的时候，使用`mutable`关键字

使用const创建的对象是常对象，常对象只能调用常函数（因为普通成员函数可以修改属性）



### 4.3 友元





#### 4.4 运算符重载

