# C语言
## 程序
### 程序的执行
* 解释：借助一个程序，那个程序能试图理解你的程序，然后按照你的要求执行
* 编译：借助一个程序，就像一个翻译，把你的程序翻译成计算机真正能懂的语言——机器语言——写的程序，然后，这个机器语言写的程序就能直接执行了
* 解释语言vs编译语言
    * 语言本无解释/编译之分，只是**常用的执行方式**
    * 解释性语言有特殊的计算能力
    * 编译型语言有确定的运算性能
* 语言的能力/适用领域主要是由
    * 库和
    * 传统所决定的
### 程序设计的任务
* 对于具有一定规模的应用程序，从确定问题到最后完成任务，一般经历以下几个工作阶段：
    * 问题分析：研究给定的条件，分析最后应达到的目标，找出解决问题的规律，选择解题的方法（忽略一些次要因素，使问题抽象化——**建立模型**）
    * 设计算法和数据结构：要设计出解题的方法和具体步骤
    * 编写程序
    * 对源程序进行编辑、编译和连接，得到可执行程序
    * 运行程序，分析结果
    * 调试和测试程序
        * 调试：发现和排除程序中的故障
        * 测试：设计出多种测试数据，检查程序对不同数据的运行情况，使之能适用于各种情况
    * 编写程序文档：正式提供给用户使用的程序，必须同时向用户提供程序说明书。说明书的内容应包括：
        * 程序名称
        * 程序功能
        * 运行环境
        * 程序的装入和启动
        * 需要输入的数据
        * 使用注意事项
* 表示算法的几个方法
    * 自然语言
    * 流程图
    * 结构化的流程图
        * 三个基本结构：顺序结构、选择结构（选取结构/分支结构）、循环结构
        * N-S图
    * 伪代码（推荐使用）
    * 计算机语言
* 写出程序只是描述算法，运行程序才是**实现算法**
* 结构化程序设计方法：自顶向下，逐步细化。用工程的方法设计程序，遵循模块化（每一个模块完成且只完成一项功能，减少耦合性，模块之间相互独立）设计方法，将问题求解由抽象化逐步具体化
    1.自顶向下
    2.逐步细化
    3.模块化设计
    4.结构化编码
## 数据
                    整数是通过二进制数（补码）形式进行存储
                    字符型数据是通过其对应的ASCII码进行存储
                    实数是通过指数（浮点数，小数点浮动，并且是以规范化的指数形式）形式进行存储
### 浮点型数据
* float（单精度实数）：能表示7位精度
* double（双精度实数）：能表示15位精度
* %f输出格式：默认小数点前输出一位，小数点后输出6位
* %10.2f：输出指定字段宽度为10，其中包含2位小数
### 无符号unsigned
* %u：以无符号十进制形式输出
### sizeof关键字
* 返回输入的类型占用的字节数
    * gcc编译系统：
        * sizeof(short):    2
        * sizeof(int):        4（int一般是计算机的字长，即寄存器的大小）
        * sizeof(long):    4

                       注：sizeof是静态运算符，它的结果在编译时期就决定了，所以在sizeof的括号里的表达式不会进行计算
### 整型常量
* 在一个整型常量后面加一个字母l或L，则认为是long int型常量
* 在一个整型常量后面加一个字母u或U，则认为是unsigned int型，按照无符号数的存储方式进行存储
### 字符量
* '\ddd'    ：1-3位八进制数所代表的字符
    * 如：'\101' : 'A'， 八进制的101是十进制的65
* '\xhh'    : 1-2位十六进制数所代表的字符
    * 如： '\x41' : 'A', 十六进制的41是十进制的65
* 字符量是一种特殊的整型量，在内存中存储的是字符的ASCii码形式，可以用unsigned和signed修饰
* 字符与字符串的区别：编译系统会在字符串的末尾隐式添加一个字符'\0'，表示字符串结束
* C语言表示字符串是通过**字符数组**进行表示的
### 布尔类型
* C99标准之后才出现
* 关键字是**bool**，需要引入`<stdbool.h>`头文件才可以使用
* 有两个值
    * true  （用十进制输出为1）
    * false （用十进制输出为0）
### 运算符
* %，++，--运算符只能用于整型变量
* float型变量运算时，必定会转换成double类型
* short，char型变量运算时，必定会转化成int类型
* int -> long -> double
* 赋值表达式是C语言的一大特色，表达式的值就是被赋值变量的值
### 预处理命令
* #include命令
    * #include <stdio.h> ：编译系统从存放C编译系统的子目录中去找所要包含的文件，这是**标准方式**
    * #include "stdio.h"   :  编译系统先在用户的当前目录（一般是用户存放源程序文件的子目录）中寻找要包含的文件，若找不到，再按照标准方式寻找
        * 双引号中可以写文件**绝对路径**
## 语句
### switch语句
* switch后面的变量的类型只能是**整型**
    * 控制表达式只能是整数型的结果
* case语句必须是常量
    * 常量可以是常数，也可以是常数计算的表达式
## 数组

> 数组的长度是一个常数
>
> C99支持数组的长度传入变量

* 数组长度
    * 使用`sizeof(数组)`函数可以得到数组在内存中占据的字节数
    
    * sizeof(a) / sizeof(a[0])    :数组长度
    
    * ```
      注意：数组作为函数参数时，往往需要再使用另一个参数来传入数组的大小
      * 不能在[]中给出数组的长度
      * 不能利用sizeof计算元素个数
      ```
    
* 数组赋值
    * 数组不可以直接通过数组变量赋值
    * 需要使用遍历将一个数组的每一个元素赋值给另一个数组
### 定义一维数组
* 可以只给一部分元素赋初值，其余元素自动为0
* int a[10] = {0};    数组元素全为0
* 对全部数组元素赋初值时，由于数据的个数已经确定，所以可以不指定数组长度
* 对数组仅声明未定义时，数组元素均为随机值

          总结：对于数值型数组，如果指定了数组长度，凡未被显示初始化的数组元素，系统会自动把它们初始化为0（如果是字符型数组，初始化为'\0'；如果是指针型数组，初始化为NULL，即空指针）
### 定义二维数组
* 对全部数组元素赋初值时，可以不指定第一维的长度，但第二维的长度必须指定，系统会根据元素总数与第二维长度计算出第一维的长度
### 字符数组
* 系统对于字符串常量会自动在最后添加一个'\0'字符
* 字符数组的有效长度是到数组中第一个出现'\0'的位置前面一个元素为止
* 系统把**空格字符**作为输入字符串之间的分隔符。如果想要输入的字符串包含空格，需要使用gets函数
### 字符串常量

* `#include <string.h>`

* 连接两个字符串常量可以直接将两个放在一起，系统会自动当成一个大字符串处理
* `char* s = "Hello,world!";`
    * s是一个指针，初始化指向一个字符串常量
        * 由于这个常量所在的地方（位于程序段，在编译时期就存在），所以实际上s是const char* s，但是由于历史原因，编译器不接受const的写法
        * 但是试图对s所指的字符串进行修改会导致严重的后果
* 如果需要修改字符串，使用数组形式
* 数组形式一般用于**构造**一个字符串
* 指针形式一般用于**处理**字符串或是**动态分配空间**
#### 字符串处理函数
* int putchar(int c)    :  返回写出的字符的ASCII码或EOF(-1)表示输出失败
* int getchar(void)    :  从标准输入读入一个字符，返回int是为了返回EOF(-1)
* EOF：
    * Windows: Ctrl + z
    * Unix: Ctrl + d
* puts(字符数组)    :将字符串（以'\0'结束的字符序列）输出到终端
* gets(字符数组)    :从终端输入一个字符串到字符数组，字符串的结束标志也存放到字符数组中
* strcat(字符数组1, 字符数组2)    :把字符数组2中的字符串接到字符数组1的字符串的后面，再将结果放到字符数组1中
    * 说明：字符数组1必须足够大，否则会因长度不够而出现问题
* strcpy(字符数组1，字符串2/字符数组2)    :把字符串2复制到字符数组1中，返回字符数组1
* strncpy(str1, str2, num)    :把str2中前面num个字符复制到str1中，代替str1的前面num个字符
* strcmp(str1, str2)    :比较str1和str2字符串
    * 比较的规则是：对两个字符串自左至右逐个字符相比（按照ASCII码），直到出现不同的字符或者'\0'为止。如果全部字符相同，则认为相等；如果出现不相同的字符，则以第一个不相同的字符的比较结果为主
    * 字符串1=字符串2，函数值为0
    * 字符串1>字符串2，函数值为正整数
    * 字符串1<字符串2，函数值为负整数
* strlen(字符数组)    :返回字符串的实际长度
* strlwr(字符串)    :返回字符串的小写
* strupr(字符串)    :返回字符串的大写
* char \*strchr(const char \*s, int c): 返回在字符串s中从左至右第一次出现字符c的指针，未找到返回NULL
* char \*strrchr(const char \*s, int c): 返回字符串s中从右至左第一次出现字符c的指针，未找到返回NULL
* char \*strstr(const char \*s1, const char \*s2): 返回字符串s1中第一次出现s2的首位置指针
* char \*strcasestr(const char \*s1, const char \*s2): 返回字符串s1中第一次出现s2的首位置指针（忽略大小写）
## 函数
### 函数原型
* 函数头，以分号“；”结尾，构成了函数的原型
* 函数原型的目的是通知编译器函数的全部信息
    * 名称
    * 参数（数量及类型）
    * 返回类型
* 函数原型可以不写参数名，但最好写上
* 每一个函数都有自己的变量空间，参数也位于这个独立的空间中
### 变量的作用域和生存期
* 内部变量（局部变量）：在一个函数内部定义的变量只能在本函数范围内有效
* 在函数内定义的变量是局部变量，而在函数之外定义的变量是外部变量或全局变量（全程变量）
    * 全局变量一般第一个字母大写
    * 全局变量的有效范围从定义变量的位置到本源文件结束
* C的**编译单位**是源程序文件
* 全局变量的作用：增加了函数间的数据联系的渠道
* 全局变量的缺点
    * 在程序的全部执行过程中都占据存储单元
    * 使函数的通用性降低了（可移植性变差），重用函数的时候还要复制函数中使用到的全局变量
    * 降低程序的清晰性，无法判断每个瞬时时刻变量的值
* 变量的生存期，即变量存在的时间。变量的存储有两种不同的方式：
    * 静态存储方式：在程序运行期间由系统分配固定的存储空间的方式
    * 动态存储方式：在程序运行期间根据需要进行动态的分配存储空间的方式
* 内存中供用户使用的存储空间分为三部分：
    * 程序区
    * 静态存储区（存储静态局部变量和全局变量）
    * 动态存储区（函数形参，未加static声明的自动变量，函数调用时现场保护和返回地址等）
* 自动变量：在调用函数时，系统会给函数中的变量分配存储空间，在函数调用结束时自动释放这些存储空间。用关键字“auto”声明，可以省略，默认为此方式
* 静态局部变量（static局部变量）：函数中局部变量的值在函数调用结束之后不消失而继续保留原值，即占用的存储单元不释放。（下一次再调用该函数时，该函数已有值，即上一次函数结束调用时的值）
    * 静态局部变量属于静态存储类别，在静态存储区中分配存储单元
    * 对静态局部变量的初始化是在编译时进行赋初值的，即只赋初值一次
    * 如果定义静态局部变量时不赋初值，对静态局部变量，编译时会自动赋初值0（数值型变量）或空字符'\0'（字符型变量）
    * 虽然静态局部变量在函数调用结束之后仍然存在，但其它函数不能引用（因为是局部变量）
* 全局变量的存储类别
    * 如果外部变量不在文件的开头定义，其有效范围是从定义处到文件结束。如果想在定义点之前使用该外部变量，则应该在引用之前用关键字extern对该变量进行“外部变量声明”（类似函数声明），表示把该外部变量的作用域扩展到此位置
        ```
        int main() {
        extern A;            // 对变量A的外部变量声明，将作用域扩展到此位置
        ···
        }
        
        int A;               // 定义外部变量A
        ···
        ```
        注：推荐在文件开头定义外部变量，不要多使用extern这种形式
    * 在一个源程序文件中引用另一个源程序文件的外部变量，可以使用extern对该变量进行“外部变量声明”。如果两个源文件模块定义了相同的外部变量，在进行程序的链接时会出现“重复定义”的错误
    * 不希望某些外部变量被其他文件引用，而只能被本文件引用，可以定义外部变量时加一个static声明。这种加上static声明，把作用域只限于本文件的外部变量叫做静态外部变量
    * 在程序中频繁使用的变量放在cpu的寄存器中，以提高效率，用register声明（不常用）
* 对于局部变量，声明存储类别的作用是指定变量的存储区域以及由此产生的生存期
* 对于外部变量，声明存储类别的作用是扩展或限制外部变量的作用域
* 对一个数据的定义，需要指定两种属性：
    * 数据类型
    * 存储类别
* 函数分为内部函数和外部函数
* 函数本质上是外部的，可以供本文件或其他文件中的函数使用，但是在其他文件中调用时要用extern对函数进行声明
* 如果在定义函数时用static声明，表示其他文件不得调用此函数，即把它“屏蔽”起来
## 指针
* 指针在声明时，`*`不做为运算符，仅代表该变量是一个指针变量
* 指针变量存放的值是该指针指向的变量的地址
* 指针变量出现在赋值表达式的右侧时，`*`作为单目运算符，结果为该指针变量指向的变量
* 指针的应用场景
    1. 交换两个数的函数
    2. 函数返回多个值，某些值就只能通过指针返回，传入的参数（指针变量）实际上是需要返回的结果
    3. 函数的返回值返回运算状态，是否成功或出现错误，函数的结果通过指针返回（被C++，Java的异常处理机制替代）
* 函数参数表中的数组实际上就是指针
    * sizeof(a) == sizeof(int *)   在非main函数的函数中（编译器将形参的数组都作为指针）
    * 但是可以用数组的下标运算符`[]`进行运算
* 数组变量是特殊的指针，该值是const，不能被修改
    * int a[10];    int *p = a;
    * 数组的单元表达的是变量，需要使用`&`取地址  a == &a[0];
    * `[]`下标运算符可以对数组使用，也可以对指针使用  p[0] == a[0];
    * `*`运算符可以对指针使用，也可以对数组使用    *a = 25
    * 编译系统将形参数组名作为指针变量来处理
* const int  \*p = &i;  表示\*p是const，即不能通过\*p修改p指向的变量的值（变量和指针不是const） 
    * 判断标志：const在\*前面还是后面
        1. const在\*号前面：  \*p不能被修改
        2. const在\*号后面：  指针p无法被修改，即永远指向同一个地址
* 当要传递的参数类型比地址大的时候，一般都传入指针，让指针指向要传递的参数类型
``` 
void f(const int* x);
既能用较少的字节数传递值给参数，又能避免函数对外面的变量做修改（一般用来传递结构体变量）
```
* const数组：  数组变量已经隐式地定义为const，此时const显示地指明数组的每一个元素是const
    * 注意：  此时数组的元素只能通过初始化赋值
* 指针`p+1`实际上是在p的地址上加上p的数据类型在内存所占据的字节数
* 指针运算
    * 给指针加一表示让指针指向下一个变量（减一也是如此），对于不是连续分配的空间如数组则无意义
    * 可以对指针进行（+，+=，-，-=，++，--）或者两个指针相减（地址值的差/sizeof（指针），指针需要指向同一个连续的内存空间）
    * 可以对指针进行比较（<，<=，>，>=，==，!=）
* \*p++：  取出p指向变量的值，并让p指向下一个变量
    * \*的优先级比++要低
    * 常用于数组类的连续空间
    * 在某些cpu上，可以被翻译成一条汇编指令
* 0地址：  属于操作系统中不能被用户程序修改的地址
* 用0地址表示：
    * 返回的指针是无效的
    * 指针没有被初始化（初始化时赋值为0）
* NULL是一个预定义的符号，表示0地址，在stdio.h中定义（有的编译器不允许使用0来表示0地址）
* 指针的类型
    * 无论指向什么类型，所有的指针的大小都是一样的，等于系统位数
    * 指针也是一种类型
    * 指向不同类型的指针不可以互相赋值，避免出错
* 指针的类型转换
    * void\*表示不知道指向什么类型，计算时与char\*相同（但不相通）
    * 指针也可以转换类型
```
    int *p = &i;
    void *q = (void*)p;
    /*
        p指向的变量仍旧是int类型，但是q虽然与p指向相同的变量，但无法根据q知道其指向的变量的类型
    */
```
* 动态内存分配
  
    * `#include <stdlib.h>`
    * void\* malloc(size_t size)
        * 向malloc申请的空间（即函数参数）的大小是以字节为单位
        * 返回的结果是void *，需要类型转换为自己需要的类型
        ```
        int* a = (int*)malloc(n * sizeof(int))
        ```
        * 如果申请失败，返回0或NULL
    * free(a):  与malloc配套使用，释放malloc函数申请的空间的首地址
        * 如果a = NULL，则不做任何事
        * 如果a不是申请空间的首地址，则系统报错
    
* 通过指针引用字符串
    * char *string = "Hello";
    * 定义了一个指针变量string，其值为"Hello"字符数组在内存中的首地址
    * "Hello"是字符串常量，无法被修改或是赋值（即字符串常量是只读的）
    * C语言的字符串是以字符数组的形式存在的（不能对字符串做运算）

* `[]`运算符的优先级高于`*`

* 指向数组的指针
```
    char week[7][10] = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
    char (*s)[10] = week;
    定义了一个7行10列二维数组，定义了一个指向10列的一维数组的指针s指向二维数组中第一个一维数组（s+2指向第3行）
```
* 指向函数的指针         系统为函数代码在内存中分配了一段连续的存储单元，其起始地址（入口地址）就是函数的指针
```
    int max(int, int);        // 声明max函数，需要两个整型参数，返回int
    int (*p)(int, int);       // 定义一个指向函数的指针p，指向返回值为int，需要两个int参数的函数
    p = max;
    c = (*p)(a, b);           // 调用p指向的函数，将a,b作为实参，返回值赋值给c，作用与c = max(a, b); 相同
```
* 返回指针的函数     返回值为变量的地址
```
    int *fun(int x, int y);  // 返回类型为(int*),即一个指向整型变量的变量
```
* 指向指针的指针
```
    char *name[] = {"Follow me", "BASIC", "Great Wall"};
    char **p;
    p = name;
    name为指针型数组，其值为char*,即字符串的首地址
```
* int \*p[4]与int (\*p)[4]不同
    * int \*p[4]: 指针数组，由4个指向int的指针元素组成
    * int (\*p)[4]: 指向包含4个元素的一维数组的指针
* int \*p()与int (\*p)()不同
    * int \*p(): 返回一个int\*类型的指针的函数
    * int (\*p)(): 定义一个指针，指向一个函数，该函数返回int



## 枚举

### 介绍

* 枚举是一种用户定义的数据类型，用关键字enum以如下语法来声明：`enum 枚举类型名{名字0, 名字1, ...}`

* 枚举类型名字通常并不真的使用，要用的是在大括号里的名字，因为它们就是常量符号，类型是int，值依次从0到n
* 声明一个枚举变量
  * `enum Color {Red, Green, Yellow}`
  * `enum Color t = Red;`
* 声明枚举类型的时候可以指定值
  * `enum Color {Red=1, Yellow, Green=5}`
* 枚举可以当做类型使用，但是不好用
* 如果有意义上排比的名字，用枚举比const int方便
* 枚举比宏macro好，因为枚举有int类型



## 结构体

### 类型

```c
struct date {
    int month;
    int day;
    int year;
};
```

* 可以在函数内部和外部声明，作用域不同

* 声明一个结构类型的变量

  * 第一种方式

    * `struct date d1;`
    * 里面有month，year，day三个变量

  * 第二种方式

    * ```c
      struct {
          int month;
          int day;
          int year;
      } p1, p2;
      ```

    * p1和p2都是一种无名结构，里面有三个变量

  * 第三种方式

    * 声明一个结构，并创建变量

    * ```c
      struct date {
          int month;
          int day;
          int year;
      } p1, p2;
      ```

* 声明并赋值

  * ```c
    // 第一种方式
    struct date today = { 04, 07, 2022 };
    
    // 第二种方式
    // 没有赋值的使用默认值
    struct date thisMonth = { .month = 7, .year = 2022 };
    ```

* 结构变量并不是结构的地址（与数组不同）



### 结构与指针

* 用`->`表示指针所指的结构变量中的成员

  * ```
    strcut date today = {04, 07, 2022};
    struct date *p = &today;
    
    // 以下两句等价
    (*p).month = 12;
    p->month = 12;
    ```



### typedef

* C语言提供一个叫做`typedef`的功能来声明一个已有的数据类型的新名字
  * `typedef int Length;`
  * Length成为int类型的别名
* 重载已有的类型名字
* 简化了复杂的名字



## 联合Union

```c
#include <stdio.h>

union AnElt {
    int i;
    char c;
};

void printAnElt(const union AnElt* elt) {
    printf("Print union AnElt:\n");
    printf("\t%d\n", elt->i);
    printf("\t%c\n", elt->c);
}

int main()
{
    union AnElt elt;
    elt.i = 3;
    printAnElt(&elt);
    elt.c = 'a';
    printAnElt(&elt);

    return 0;
}
```

* 所有的成员共享一份内存空间，修改其中一个值，其他的变量也会级联修改
  * 同一时间只有一个变量是有效的
* sizeof(union) = sizeof(每个成员)的最大值
  * union的大小是其最大的成员的大小



## 变量和作用域

### 全局变量

* 系统会默认初始化，发生在main函数之前
* 初始化只能使用编译时刻已知的值

tips:

* 不要使用全局变量在函数间传递参数和结果
* 尽量避免使用全局变量
* 使用全局变量和静态本地变量的函数是线程不安全的



### 全局变量的声明

当变量使用在整个项目的时候，需要使用的地方要声明该变量`extern int i;`

使用关键字extern



### 静态本地变量

* 在本地变量的定义时，加上`static`修饰符就成为本地变量
* 当函数离开的时候，静态本地变量会继续存在并保持其值
* 静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数时会保持上次离开的值
* （本质是全局变量，位于相同的内存区域，具有**全局的生存期和函数内部的作用域**）



### 返回指针的函数

* 返回本地变量的地址是危险的
* 返回全局变量或静态本地变量是安全的
* 返回在函数内malloc的内存是安全的，但是容易造成问题
* 最好的做法是返回传入的指针



### 一些预先定义的宏

* `__func__`
  * 字符串，表示当前函数的名字
* `__LINE__`
  * 当前源代码文件的行号
* `__FILE__`
  * 文件的绝对路径
* `__DATE__`
  * 当前日期
* `__TIME__`
  * 当前时间
* `__STDC__`



### 条件编译

```c
#ifndef _MAX_
#define _MAX_ ...
#endif
```



## 头文件

* 把函数原型放到一个头文件（.h结尾）中，在需要调用这个函数的源文件（.c文件）中include这个头文件，就能让编译器在编译的时候知道函数的原型
* #include有两种形式
  * “”要求编译器先找当前目录，再找编译器指定目录
  * <>要求编译器只找指定的目录
* 只有声明可以放在头文件中（规则）
  * 否则会造成一个项目多个编译单元有重名的实体




## 不对外公开的东西

### 函数

* 在函数前面加上static就使得它成为只能在所在编译单元中被使用的函数

### 变量

* 在全局变量前面加上static就使得它成为只能在编译单元使用的变量



## IO

### 格式化输入输出

`sprintf(string s, "%%%ds", int i);`

向字符串s输出一个%和数字i和字符s

![image-20220412080540550](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220412080540550.png)

![image-20220412081053323](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220412081053323.png)

![image-20220412081249724](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220412081249724.png)

![image-20220412081424062](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220412081424062.png)

![image-20220412081743677](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220412081743677.png)

![image-20220412081825899](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220412081825899.png)

`[^...]`: 不允许的字符



### 文件输入输出

使用`<`或`>`做输入输出重定向

![image-20220412082408745](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220412082408745.png)

![image-20220412082456799](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220412082456799.png)

![image-20220412082651981](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220412082651981.png)



### 二进制读写

![image-20220412083641806](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220412083641806.png)

![image-20220412084345598](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220412084345598.png)



## 可变数组

![image-20220412222207311](C:\Users\bzhan\AppData\Roaming\Typora\typora-user-images\image-20220412222207311.png)



### VariableArray.h

```c
#ifndef _ARRAY_H_
#define _ARRAY_H_

typedef struct {
    int* array;
    int size;
} Array;

Array array_create(int init_size);
void array_free(Array *a);
int array_size(const Array* a);
int* array_at(Array*a, int index);
void array_inflate(Array *a, int more_size);
#endif
```



### VariableArray.c

```c
#include <stdio.h>
#include <stdlib.h>
#include "VariableArray.h"
#include <string.h>

Array array_create(int init_size)
{
    Array arr;
    arr.array = (int*)malloc(init_size * sizeof(int));
    arr.size = init_size;
    return arr;
}

void array_free(Array* a)
{
    free(a->array);
    a->array = NULL;
    a->size = 0;
}

int array_size(const Array* a)
{
    return a->size;
}

int* array_at(Array* a, int index)
{
    return &(a->array[index]);
}

void array_inflate(Array* a, int more_size)
{
    Array p = array_create(a->size + more_size);
    //for (int i = 0; i < a->size; i++)
    //{
    //    p.array[i] = a->array[i];
    //}
    memcpy(p.array, a->array, a->size * sizeof(int));
    
    array_free(a);
    a->array = p.array;
    a->size = p.size;
}
```



### main.c

```c
#include <stdio.h>
#include "VariableArray.h"
#define _CRT_SECURE_NO_WARNINGS

int main()
{
    Array arr = array_create(3);
    for (int i = 0; i < arr.size; i++)
    {
        int x;
        scanf_s("%d", &x);
        *array_at(&arr, i) = x;

        //scanf_s("%d", element, 4);
    }
    array_inflate(&arr, 3);
    for (int i = 0; i < arr.size; i++)
    {
        int* element = array_at(&arr, i);
        printf_s("%d\t", *element);
    }
    printf("\n%d", array_size(&arr));  // 6
    return 0;
}
```



## 链表





## 常用函数

### memcpy

```c
#include <string.h>

函数原型：
void *memcpy(void *destin, void
*source, unsigned n);

参数：
destin–
指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。
source–
指向要复制的数据源，类型强制转换为
void* 指针。
n-- 要被复制的字节数。
```

